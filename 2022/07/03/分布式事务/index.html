<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>分布式事务 | Jason</title><meta name="keywords" content="分布式事务"><meta name="author" content="高明辉"><meta name="copyright" content="高明辉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分布式事务学习目标12341- 了解分布式事务产生的原因2- 知道几种分布式事务解决方案3- 知道分布式事务各种解决方案的优缺点和使用场景4- 学会使用Seata来解决分布式事务  总结写在前面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式事务">
<meta property="og:url" content="http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/index.html">
<meta property="og:site_name" content="Jason">
<meta property="og:description" content="分布式事务学习目标12341- 了解分布式事务产生的原因2- 知道几种分布式事务解决方案3- 知道分布式事务各种解决方案的优缺点和使用场景4- 学会使用Seata来解决分布式事务  总结写在前面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2022-07-03T01:53:12.000Z">
<meta property="article:modified_time" content="2022-08-02T14:24:43.295Z">
<meta property="article:author" content="高明辉">
<meta property="article:tag" content="分布式事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%B0%81%E9%9D%A2.png"><link rel="shortcut icon" href="/img/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.png"><link rel="canonical" href="http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式事务',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-02 22:24:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jason" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">206</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%B0%81%E9%9D%A2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jason</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式事务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-03T01:53:12.000Z" title="发表于 2022-07-03 09:53:12">2022-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-02T14:24:43.295Z" title="更新于 2022-08-02 22:24:43">2022-08-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/">乐优商城项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="分布式事务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1-</span> <span class="string">了解分布式事务产生的原因</span></span><br><span class="line"><span class="meta">2-</span> <span class="string">知道几种分布式事务解决方案</span></span><br><span class="line"><span class="meta">3-</span> <span class="string">知道分布式事务各种解决方案的优缺点和使用场景</span></span><br><span class="line"><span class="meta">4-</span> <span class="string">学会使用Seata来解决分布式事务</span></span><br></pre></td></tr></table></figure>

<p>总结写在前面：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">事务管理：</span></span><br><span class="line">    <span class="meta">下单行为</span> <span class="string">一个事务</span></span><br><span class="line">    <span class="meta">减库存行为</span> <span class="string">一个事务</span></span><br><span class="line">    <span class="attr">但是这两个事务不是同一个线程的事务（微服都不同），我们实际需求是把它们当做同一个事务。</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">虽然减库存代码itemClient.minusStock(carts)放在加了事务的createOrder方法内，</span></span><br><span class="line">    <span class="attr">但是减库存跟下单方法不是同一个事务管理器。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">理论学习：</span></span><br><span class="line">	<span class="attr">本地事务：（单服务单数据库），利用数据库的ACID（原子性，一致性，隔离性，持久性）就能实现事务控制。</span></span><br><span class="line">	<span class="meta">分布式事务：1</span> <span class="string">跨服务，2 跨数据库  3 跨服务+数据库</span></span><br><span class="line"></span><br><span class="line"><span class="attr">跨数据库事务管理：</span></span><br><span class="line">	<span class="attr">使用数据库集群，当不同数据库数据不一致时，如何响应用户访问？？？</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CAP</span> <span class="string">定理：</span></span><br><span class="line">	<span class="attr">强一致性C：等不同数据库数据一致时才响应用户！</span></span><br><span class="line">	<span class="attr">高可用性A：数据库直接响应本数据库数据</span></span><br><span class="line">	<span class="attr">分区容错性P：区间通信可能失败，（客观存在的）</span></span><br><span class="line">			<span class="attr">比如，一台服务器放在上海，另一台服务器放在北京，这就是两个区，它们之间可能因网络问题无法通信。</span></span><br><span class="line"><span class="meta">这三个指标不可能同时做到。这个结论就叫做</span> <span class="string">CAP 定理。就看你侧重于可用性还是容错性！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">总结：加了事务的主方法内有引用的多个方法跟主方法不是同一个事务管理器，那么就需要分布式事务管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">方案1</span> <span class="string">：业务执行，然后上报结果给协调器，根据协调器指示进行提交或者回滚</span></span><br><span class="line">	<span class="attr">（一旦有一个事务错误，立即所有事务回滚，否则等全部事务成功后再提交）</span></span><br><span class="line">	<span class="attr">（缺点就是系统延迟，性能下降）</span></span><br><span class="line"><span class="meta">方案2</span> <span class="string">：利用tcc（try confirm cancel）解决方案：(性能最好的分布式事务方式)</span></span><br><span class="line">	<span class="attr">同一个事务管理器的事务执行业务后该提交提交，该回滚回滚，</span></span><br><span class="line">	<span class="attr">如果有一个回滚了，那么其他提交了的事务就要做事务补偿！</span></span><br><span class="line"><span class="attr">方案3：AT模式</span></span><br><span class="line">	<span class="meta">-</span> <span class="string">一阶段：执行本地事务，并返回执行结果</span></span><br><span class="line">	<span class="meta">-</span> <span class="string">二阶段：根据一阶段的结果，判断二阶段做法：提交或回滚（补偿）</span></span><br><span class="line">	<span class="meta">在</span> <span class="string">AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</span></span><br><span class="line"><span class="attr">等方案...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">使用Seata</span> <span class="string">框架下的AT模式进行分布式事务控制，引入到我们的项目中！</span></span><br><span class="line"><span class="attr">1</span> <span class="string">官网下载Seata框架（Seata是一个面向服务编程框架）(下载解压即安装)</span></span><br><span class="line"><span class="attr">2</span> <span class="string">修改registry.conf 跟file.conf文件</span></span><br><span class="line">	<span class="attr">registry.conf为了给seata服务指定我们整个项目的注册中心的配置文件</span></span><br><span class="line">	<span class="meta">file.conf</span> <span class="string">是Seata服务的配置文件，给seata指定数据库，以及需要什么表，因此我们要在数据库建立对应库表。</span></span><br><span class="line"><span class="attr">3</span> <span class="string">启动Seata服务框架（运行.bat文件,）</span></span><br><span class="line"><span class="attr">4</span> <span class="string">改造原Order服务</span></span><br><span class="line">	<span class="attr">（1）引入seata依赖</span></span><br><span class="line">	<span class="attr">（2）application.yml中添加配置，定义事务组名称</span></span><br><span class="line">	<span class="attr">（3）`resources`目录下放两个配置文件：`file.conf`和`registry.conf`</span></span><br><span class="line">	<span class="attr">（4）对DataSource做代理</span></span><br><span class="line">		<span class="attr">Seata的二阶段执行是通过拦截sql语句，分析语义来指定回滚策略，</span></span><br><span class="line">		<span class="attr">因此需要对DataSource做代理。</span></span><br><span class="line">		<span class="attr">我们在项目的`cn.itcast.order.config`包中，添加一个配置类</span></span><br><span class="line">	<span class="attr">（5）添加事务注解</span></span><br><span class="line">		<span class="attr">给事务发起者`order_service`的`OrderServiceImpl`中的`create()`方法</span></span><br><span class="line">		<span class="attr">添加`@GlobalTransactional`注解，开启全局事务</span></span><br><span class="line"><span class="attr">5</span> <span class="string">改造Storage、Account服务</span></span><br><span class="line">	<span class="meta">-</span> <span class="string">引入依赖：与order-service一致，略</span></span><br><span class="line">	<span class="meta">-</span> <span class="string">添加配置文件：与order-service一致，略</span></span><br><span class="line">	<span class="meta">-</span> <span class="string">代理DataSource，我们的storage-service和account-service都没有用mybatis-plus，</span></span><br><span class="line">		<span class="attr">所以配置要使用SqlSessionFactory：</span></span><br><span class="line">	<span class="attr">另外，事务注解可以使用`@Transactionnal`，而不是`@GlobalTransactional`，</span></span><br><span class="line">	<span class="attr">事务发起者才需要添加`@GlobalTransactional`。</span></span><br></pre></td></tr></table></figure>



<h1 id="1-什么是分布式事务"><a href="#1-什么是分布式事务" class="headerlink" title="1.什么是分布式事务"></a>1.什么是分布式事务</h1><p>我们已经完成了下单的业务，但是下单业务中会包含多个微服务的调用，例如：</p>
<ul>
<li>订单微服务：新增订单、订单详情、订单物流</li>
<li>商品微服务：扣减库存</li>
<li>优惠券服务：扣减用户优惠券</li>
<li>…</li>
</ul>
<p>要了解分布式事务，必须先了解本地事务。</p>
<h2 id="1-1-本地事务"><a href="#1-1-本地事务" class="headerlink" title="1.1.本地事务"></a>1.1.本地事务</h2><p>事务，是指传统的单机数据库事务，必须具备ACID原则：</p>
<ul>
<li><strong>原子性（A）</strong></li>
</ul>
<p>所谓的原子性就是说，在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。</p>
<ul>
<li><strong>一致性（C）</strong></li>
</ul>
<p>事务的执行必须保证系统的一致性，就拿转账为例，A有500元，B有500元，如果在一个事务里A成功转给B50元，那么不管发生什么，那么最后A账户和B账户的数据之和必须是1000元。</p>
<ul>
<li><strong>隔离性（I）</strong></li>
</ul>
<p>所谓的隔离性就是说，事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。</p>
<ul>
<li><strong>持久性（D）</strong></li>
</ul>
<p>所谓的持久性，就是说一单事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。</p>
<p>因为在传统项目中，项目部署基本是单点式：即单个服务器和单个数据库。这种情况下，数据库本身的事务机制就能保证ACID的原则，这样的事务就是本地事务。</p>
<p>概括来讲，单个服务与单个数据库的架构中，产生的事务都是本地事务。</p>
<h2 id="1-2-分布式事务"><a href="#1-2-分布式事务" class="headerlink" title="1.2.分布式事务"></a>1.2.分布式事务</h2><p>分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务：</p>
<ul>
<li>跨数据源的分布式事务</li>
<li>跨服务的分布式事务</li>
<li>综合情况</li>
</ul>
<h3 id="1）跨数据源"><a href="#1）跨数据源" class="headerlink" title="1）跨数据源"></a>1）跨数据源</h3><p>随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片，于是就产生了跨数据库事务问题。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304201018438.png" alt="image-20200304201018438"></p>
<h3 id="2）跨服务"><a href="#2）跨服务" class="headerlink" title="2）跨服务"></a>2）跨服务</h3><p>在业务发展初期，“一块大饼”的单业务系统架构，能满足基本的业务需求。但是随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈，解决业务系统的高耦合、可伸缩问题的需求越来越强烈。</p>
<p>如下图所示，按照面向服务（SOA）的架构的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304202639509.png" alt="image-20200304202639509"></p>
<h3 id="3）分布式系统的数据一致性问题"><a href="#3）分布式系统的数据一致性问题" class="headerlink" title="3）分布式系统的数据一致性问题"></a>3）分布式系统的数据一致性问题</h3><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。在分布式网络环境下，我们无法保障所有服务、数据库都百分百可用，一定会出现部分服务、数据库执行成功，另一部分执行失败的问题。</p>
<p>当出现部分业务操作成功、部分业务操作失败时，业务数据就会出现不一致。</p>
<p>例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p>
<ul>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ul>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304204442839.png" alt="image-20200304204442839"></p>
<p>在分布式环境下，肯定会出现部分操作成功、部分操作失败的问题，比如：订单生成了，库存也扣减了，但是 用户账户的余额不足，这就造成数据不一致。</p>
<p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p>
<p>但是当我们把三件事情看做一个事情事，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。</p>
<p>此时ACID难以满足，这是分布式事务要解决的问题</p>
<h1 id="2-解决分布式事务的思路"><a href="#2-解决分布式事务的思路" class="headerlink" title="2.解决分布式事务的思路"></a>2.解决分布式事务的思路</h1><p>为什么分布式系统下，事务的ACID原则难以满足？</p>
<p>这得从CAP定理和BASE理论说起。</p>
<h2 id="2-1-CAP定理"><a href="#2-1-CAP定理" class="headerlink" title="2.1.CAP定理"></a>2.1.CAP定理</h2><p>本小节内容摘自：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/07/cap.html">CAP 定理的含义</a></p>
<p>什么是CAP定理呢？</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304205842784.png" alt="image-20200304205842784"> </p>
<p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p>
<blockquote>
<ul>
<li>Consistency（一致性）</li>
<li>Availability（可用性）</li>
<li>Partition tolerance （分区容错性）</li>
</ul>
</blockquote>
<p>它们的第一个字母分别是 C、A、P。</p>
<p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p>
<h3 id="2-1-1-Partition-tolerance"><a href="#2-1-1-Partition-tolerance" class="headerlink" title="2.1.1.Partition tolerance"></a>2.1.1.Partition tolerance</h3><p>先看 Partition tolerance，中文叫做”分区容错”。</p>
<p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在上海，另一台服务器放在北京，这就是两个区，它们之间可能因网络问题无法通信。</p>
<p>如图：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210120471.png" alt="image-20200304210120471"> </p>
<p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p>
<p>一般来说，分布式系统，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。根据CAP 定理，剩下的 C 和 A 无法同时做到。</p>
<h3 id="2-1-2-Consistency"><a href="#2-1-2-Consistency" class="headerlink" title="2.1.2.Consistency"></a>2.1.2.Consistency</h3><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210414309.png" alt="image-20200304210414309"> </p>
<p>接下来，用户的读操作就会得到 v1。这就叫一致性。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210506575.png" alt="image-20200304210506575"> </p>
<p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210521364.png" alt="image-20200304210521364"></p>
<p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210540168.png" alt="image-20200304210540168"> </p>
<p>这样的话，用户向 G2 发起读操作，也能得到 v1。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200304210557117.png" alt="image-20200304210557117"> </p>
<h3 id="2-1-3-Availability"><a href="#2-1-3-Availability" class="headerlink" title="2.1.3.Availability"></a>2.1.3.Availability</h3><p> Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应（对和错不论）。</p>
<p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p>
<h3 id="2-1-4-Consistency-和-Availability-的矛盾"><a href="#2-1-4-Consistency-和-Availability-的矛盾" class="headerlink" title="2.1.4.Consistency 和 Availability 的矛盾"></a>2.1.4.Consistency 和 Availability 的矛盾</h3><p>一致性和可用性，为什么不可能同时成立？</p>
<p>答案很简单，因为可能通信失败（即出现分区容错）。</p>
<p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。</p>
<p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p>
<p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p>
<h3 id="2-1-5-几点疑问"><a href="#2-1-5-几点疑问" class="headerlink" title="2.1.5.几点疑问"></a>2.1.5.几点疑问</h3><ul>
<li><p>怎样才能同时满足CA？</p>
<p>除非是单点架构</p>
</li>
<li><p>何时要满足CP？</p>
<p>对一致性要求高的场景。例如我们的Zookeeper就是这样的，在服务节点间数据同步时，服务对外不可用。</p>
</li>
<li><p>何时满足AP？</p>
<p>对可用性要求较高的场景。例如Eureka，必须保证注册中心随时可用，不然拉取不到服务就可能出问题。</p>
</li>
</ul>
<h2 id="2-2-Base理论"><a href="#2-2-Base理论" class="headerlink" title="2.2.Base理论"></a>2.2.Base理论</h2><p>BASE是三个单词的缩写：</p>
<ul>
<li><p>Basically Available（基本可用）</p>
</li>
<li><p>Soft state（软状态）</p>
</li>
<li><p>Eventually consistent（最终一致性）</p>
</li>
</ul>
<p>而我们解决分布式事务，就是根据上述理论来实现。</p>
<p>还以上面的下单减库存和扣款为例：</p>
<p>订单服务、库存服务、用户服务及他们对应的数据库就是分布式应用中的三个部分。</p>
<ul>
<li><p>CP方式：现在如果要满足事务的强一致性，就必须在订单服务数据库锁定的同时，对库存服务、用户服务数据资源同时锁定。等待三个服务业务全部处理完成，才可以释放资源。此时如果有其他请求想要操作被锁定的资源就会被阻塞，这样就是满足了CP。</p>
<p>这就是强一致，弱可用</p>
</li>
<li><p>AP方式：三个服务的对应数据库各自独立执行自己的业务，执行本地事务，不要求互相锁定资源。但是这个<code>中间状态</code>下，我们去访问数据库，可能遇到数据不一致的情况，不过我们需要做一些后补措施，保证在经过一段时间后，数据最终满足一致性。</p>
<p>这就是高可用，但弱一致（最终一致）。</p>
</li>
</ul>
<p>由上面的两种思想，延伸出了很多的分布式事务解决方案：</p>
<ul>
<li>XA</li>
<li>TCC</li>
<li>可靠消息最终一致</li>
<li>TA</li>
</ul>
<p>不过，要想搞懂这些原理，你必须知道数据库本地事务是如何实现的，也就是undo和redo日志的故事。</p>
<h2 id="2-3-undo和redo"><a href="#2-3-undo和redo" class="headerlink" title="2.3.undo和redo"></a>2.3.undo和redo</h2><p>本小节参考内容：<a target="_blank" rel="noopener" href="http://www.zhdba.com/mysqlops/2012/04/06/innodb-log1/">mysqlops</a></p>
<p>在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。</p>
<p>MySQL中的日志文件，有这么两类与事务有关：undo日志与redo日志。</p>
<h3 id="2-3-1-undo日志"><a href="#2-3-1-undo日志" class="headerlink" title="2.3.1.undo日志"></a>2.3.1.undo日志</h3><p>数据库事务具备原子性（<strong>Atomicity</strong>），如果事务执行失败，需要把数据回滚。</p>
<p>事务同时还具备持久性**(Durability)**，事务对数据所做的变更就完全保存在了数据库，不能因为故障而丢失。</p>
<p>持久性和原子性可以利用undo日志来实现。</p>
<p>Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到Undo Log。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p>
<p>数据库写入数据到磁盘之前，会把<strong>数据先缓存在内存</strong>中，事务提交时才会写入磁盘中。</p>
<p>用Undo Log实现原子性和持久化的事务的简化过程：</p>
<p> 假设有A、B两个数据，值分别为1,2。<br> A. 事务开始.<br> B. 记录A=1到undo log buffer.<br> C. 修改A=3.<br> D. 记录B=2到undo log buffer.<br> E. 修改B=4.<br> F. 将undo log buffer写到磁盘。<br> G. 将数据写到磁盘。<br> H. 事务提交</p>
<ul>
<li><p>如何保证原子性？</p>
<p>在修改数据到磁盘前，会先记录undo log，并将undo log持久化到硬盘</p>
</li>
<li><p>如何保证持久性？</p>
<p>在事务提交之前，把内存中缓存的数据写入磁盘。这样事务提交时，可以确定数据是已经持久化的，不会丢失。</p>
</li>
<li><p>若系统在G和H之间崩溃</p>
<p>此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据</p>
</li>
<li><p>若系统在G之前崩溃</p>
<p>此时数据并未持久化到硬盘，依然保持在事务之前的状态</p>
</li>
</ul>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即<strong>Redo Log</strong>.</p>
<h3 id="2-3-2-redo日志"><a href="#2-3-2-redo日志" class="headerlink" title="2.3.2.redo日志"></a>2.3.2.redo日志</h3><p>和Undo Log相反，Redo Log记录的是<strong>新数据</strong>的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化，减少了IO的次数。</p>
<p>先来看下基本原理：</p>
<blockquote>
<p><strong>Undo + Redo事务的简化过程</strong></p>
</blockquote>
<p> 假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A=1到undo log.<br> C. 修改A=3.<br> D. 记录A=3到redo log.<br> E. 记录B=2到undo log.<br> F. 修改B=4.<br> G. 记录B=4到redo log.<br> H. 将undo log写入磁盘<br> I. 将redo log写入磁盘<br> J. 事务提交</p>
<blockquote>
<p>安全和性能问题</p>
</blockquote>
<ul>
<li><p>如何保证原子性？</p>
<p>如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚</p>
</li>
<li><p>如何保证持久化？</p>
<p>大家会发现，这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了<code>I</code>以后，事务是可以提交的。</p>
</li>
<li><p>内存中的数据库数据何时持久化到磁盘？</p>
<p>因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照固设定的频率刷新内存数据到磁盘中）。</p>
</li>
<li><p>持久化redo和持久化数据库数据有什么性能差异？</p>
<ul>
<li><p>数据库数据写入是随机IO，性能很差</p>
</li>
<li><p>redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好</p>
</li>
</ul>
</li>
<li><p>redo log中记录的数据，有可能尚未提交，那么如何完成数据恢复？</p>
<p>数据恢复有两种策略：</p>
<ul>
<li>恢复时，只重做已经提交了的事务</li>
<li>恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务</li>
</ul>
<p>Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化</p>
</li>
<li><p>写入性能的优化</p>
<p>事务提交前需要同时写入undo log和 redo log，势必增加IO次数，因此实际上undo log并不是直接写入磁盘，而是先写入到redo log中，当redo log持久化时，undo log就同时持久化到硬盘了。</p>
<p>因此事务提交前，只需要对redo log持久化即可。</p>
<p>另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池：<code>redo log buffer</code>。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO此时。</p>
</li>
</ul>
<h3 id="2-3-3-总结"><a href="#2-3-3-总结" class="headerlink" title="2.3.3.总结"></a>2.3.3.总结</h3><p>最后总结一下：</p>
<ul>
<li>undo log 记录更新前数据，用于保证事务原子性</li>
<li>redo log 记录更新后数据，用于保证事务的持久性</li>
<li>redo log有自己的内存buffer，先写入到buffer，事务提交时写入磁盘</li>
<li>redo log持久化之后，意味着事务是<strong>可提交</strong>的</li>
</ul>
<h2 id="2-4-分阶段提交"><a href="#2-4-分阶段提交" class="headerlink" title="2.4.分阶段提交"></a>2.4.分阶段提交</h2><h3 id="2-4-1DTP和XA"><a href="#2-4-1DTP和XA" class="headerlink" title="2.4.1DTP和XA"></a>2.4.1DTP和XA</h3><p>分布式事务的解决手段之一，就是两阶段提交协议（2PC：Two-Phase Commit）</p>
<p>那么到底什么是两阶段提交协议呢？</p>
<p>1994 年，X/Open 组织（即现在的 Open Group ）定义了分布式事务处理的DTP 模型。该模型包括这样几个角色：</p>
<ul>
<li>应用程序（ AP ）：我们的微服务</li>
<li>事务管理器（ TM ）：全局事务管理者</li>
<li>资源管理器（ RM ）：一般是数据库</li>
<li>通信资源管理器（ CRM ）：是TM和RM间的通信中间件</li>
</ul>
<p>在该模型中，一个分布式事务（全局事务）可以被拆分成许多个本地事务，运行在不同的AP和RM上。每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每一个本地事务都能同时成功，若有一个本地事务失败，则所有其它事务都必须回滚。但问题是，本地事务处理过程中，并不知道其它事务的运行状态。因此，就需要通过CRM来通知各个本地事务，同步事务执行的状态。</p>
<p>因此，各个本地事务的通信必须有统一的标准，否则不同数据库间就无法通信。<strong>XA</strong>就是 X/Open DTP中通信中间件与TM间联系的<strong>接口规范</strong>，定义了用于通知事务开始、提交、终止、回滚等接口，各个数据库厂商都必须实现这些接口。</p>
<h3 id="2-4-2-二阶段提交"><a href="#2-4-2-二阶段提交" class="headerlink" title="2.4.2.二阶段提交"></a>2.4.2.二阶段提交</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35298019">漫话分布式系统共识协议: 2PC/3PC篇</a></p>
<p><strong>二阶提交协议</strong>就是根据这一思想衍生出来的，将全局事务拆分为两个阶段来执行：</p>
<ul>
<li>阶段一：准备阶段，各个本地事务完成本地事务的准备工作。（这里的准备指的是事务提交完成）</li>
<li>阶段二：执行阶段，各个本地事务根据上一阶段执行结果，进行提交或回滚。</li>
</ul>
<p>这个过程中需要一个协调者（coordinator），还有事务的参与者（voter）。</p>
<blockquote>
<p>1）正常情况</p>
</blockquote>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305141029973.png" alt="image-20200305141029973"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行成功的信息（<code>agree</code>）</p>
<p><strong>提交阶段</strong>：协调组发现每个参与者都可以执行事务（<code>agree</code>），于是向各个事务参与者发出<code>commit</code>指令，各个事务参与者提交事务。</p>
<blockquote>
<p>2）异常情况</p>
</blockquote>
<p>当然，也有异常的时候：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305141318326.png" alt="image-20200305141318326"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行结果，但只要有一个参与者返回的是<code>Disagree</code>，则说明执行失败。</p>
<p><strong>提交阶段</strong>：协调组发现有一个或多个参与者返回的是<code>Disagree</code>，认为执行失败。于是向各个事务参与者发出<code>abort</code>指令，各个事务参与者回滚事务。</p>
<blockquote>
<p>3）缺陷</p>
</blockquote>
<p>二阶段提交的问题：</p>
<ul>
<li><p>单点故障问题</p>
<p>2PC的缺点在于不能处理fail-stop形式的节点failure. 比如下图这种情况.</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305142812815.png" alt="image-20200305142812815"> </p>
<p>假设coordinator和voter3都在Commit这个阶段crash了, 而voter1和voter2没有收到commit消息. 这时候voter1和voter2就陷入了一个困境. 因为他们并不能判断现在是两个场景中的哪一种:</p>
<p> (1)上轮全票通过然后voter3第一个收到了commit的消息并在commit操作之后crash了</p>
<p> (2)上轮voter3反对所以干脆没有通过.</p>
</li>
<li><p>阻塞问题</p>
<p>在准备阶段、提交阶段，每个事物参与者都会锁定本地资源，并等待其它事务的执行结果，阻塞时间较长，资源锁定时间太久，因此执行的效率就比较低了。</p>
</li>
</ul>
<p>面对二阶段提交的上述缺点，后来又演变出了三阶段提交，但是依然没有完全解决阻塞和资源锁定的问题，而且引入了一些新的问题，因此实际使用的场景较少。</p>
<h3 id="2-4-3-使用场景"><a href="#2-4-3-使用场景" class="headerlink" title="2.4.3.使用场景"></a>2.4.3.使用场景</h3><p><strong>对事务有强一致性要求，对事务执行效率不敏感，并且不希望有太多代码侵入。</strong></p>
<h2 id="2-5-TCC"><a href="#2-5-TCC" class="headerlink" title="2.5.TCC"></a>2.5.TCC</h2><p>TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。它采用的是一种<code>补偿型事务</code>的思想。</p>
<h3 id="2-5-1-基本原理"><a href="#2-5-1-基本原理" class="headerlink" title="2.5.1.基本原理"></a>2.5.1.基本原理</h3><p>它本质是一种补偿的思路。事务运行过程包括三个方法，</p>
<ul>
<li>Try：资源的检测和预留；</li>
<li>Confirm：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；</li>
<li>Cancel：预留资源释放。</li>
</ul>
<p>执行分两个阶段：</p>
<ul>
<li>准备阶段（try）：资源的检测和预留；</li>
<li>执行阶段（confirm/cancel）：根据上一步结果，判断下面的执行方法。如果上一步中所有事务参与者都成功，则这里执行confirm。反之，执行cancel</li>
</ul>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305155521612.png" alt="image-20200305155521612"> </p>
<p>粗看似乎与两阶段提交没什么区别，但其实差别很大：</p>
<ul>
<li>try、confirm、cancel都是独立的事务，不受其它参与者的影响，不会阻塞等待它人</li>
<li>try、confirm、cancel由程序员在业务层编写，锁粒度有代码控制</li>
</ul>
<h3 id="2-5-2-实例"><a href="#2-5-2-实例" class="headerlink" title="2.5.2.实例"></a>2.5.2.实例</h3><p>我们以之前的下单业务中的扣减余额为例来看下三个不同的方法要怎么编写，假设账户A原来余额是100，需要余额扣减30元。如图：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305155830732.png" alt="image-20200305155830732"></p>
<ul>
<li><p>一阶段（Try）：余额检查，并冻结用户部分金额，此阶段执行完毕，事务已经提交</p>
<ul>
<li>检查用户余额是否充足，如果充足，冻结部分余额</li>
<li>在账户表中添加冻结金额字段，值为30，余额不变</li>
</ul>
</li>
<li><p>二阶段</p>
<ul>
<li>提交（Confirm）：真正的扣款，把冻结金额从余额中扣除，冻结金额清空<ul>
<li>修改冻结金额为0，修改余额为100-30 = 70元</li>
</ul>
</li>
<li>补偿（Cancel）：释放之前冻结的金额，<strong>并非回滚</strong><ul>
<li>余额不变，修改账户冻结金额为0</li>
</ul>
</li>
</ul>
<p><strong>这个阶段产生两个事务！！！</strong></p>
</li>
</ul>
<h3 id="2-5-3-优势和缺点"><a href="#2-5-3-优势和缺点" class="headerlink" title="2.5.3.优势和缺点"></a>2.5.3.优势和缺点</h3><ul>
<li><p><strong>优势</strong></p>
<p>TCC执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就<strong>避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能最好的分布式事务方式。</strong></p>
</li>
<li><p><strong>缺点</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-</span> <span class="string">1 代码侵入：需要人为编写代码实现，代码侵入较多</span></span><br><span class="line"><span class="meta">-</span> <span class="string">2 开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂</span></span><br><span class="line"><span class="meta">-</span> <span class="string">3 安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-4-使用场景"><a href="#2-5-4-使用场景" class="headerlink" title="2.5.4.使用场景"></a>2.5.4.使用场景</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-</span> <span class="string">对事务有一定的一致性要求（最终一致）</span></span><br><span class="line"><span class="meta">-</span> <span class="string">对性能要求较高</span></span><br><span class="line"><span class="meta">-</span> <span class="string">开发人员具备较高的编码能力和幂等处理经验</span></span><br></pre></td></tr></table></figure>


<h2 id="2-6-可靠消息服务"><a href="#2-6-可靠消息服务" class="headerlink" title="2.6.可靠消息服务"></a>2.6.可靠消息服务</h2><p>这种实现方式的思路，其实是源于ebay，其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。</p>
<h3 id="2-6-1-基本原理"><a href="#2-6-1-基本原理" class="headerlink" title="2.6.1.基本原理"></a>2.6.1.基本原理</h3><p>一般分为事务的发起者A和事务的其它参与者B：</p>
<ul>
<li>事务发起者A执行本地事务</li>
<li>事务发起者A通过MQ将需要执行的事务信息发送给事务参与者B</li>
<li>事务参与者B接收到消息后执行本地事务</li>
</ul>
<p>如图：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305181454125.png" alt="image-20200305181454125"></p>
<p>这个过程有点像你去学校食堂吃饭：</p>
<ul>
<li>拿着钱去收银处，点一份红烧牛肉面，付钱</li>
<li>收银处给你发一个小票，还有一个号牌，你别把票弄丢！</li>
<li>你凭小票和号牌一定能领到一份红烧牛肉面，不管需要多久</li>
</ul>
<p>几个注意事项：</p>
<ul>
<li>事务发起者A必须确保本地事务成功后，消息一定发送成功</li>
<li>MQ必须保证消息正确投递和持久化保存</li>
<li>事务参与者B必须确保消息最终一定能消费，如果失败需要多次重试</li>
<li>事务B执行失败，会重试，但不会导致事务A回滚</li>
</ul>
<p>那么问题来了，我们如何保证消息发送一定成功？如何保证消费者一定能收到消息？</p>
<h3 id="2-6-2-本地消息表"><a href="#2-6-2-本地消息表" class="headerlink" title="2.6.2.本地消息表"></a>2.6.2.本地消息表</h3><p>为了避免消息发送失败或丢失，我们可以把消息持久化到数据库中。实现时有简化版本和解耦合版本两种方式。</p>
<h4 id="1）简化版本"><a href="#1）简化版本" class="headerlink" title="1）简化版本"></a>1）简化版本</h4><p>原理图：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305183431211.png" alt="image-20200305183431211"> </p>
<ul>
<li><p>事务发起者：</p>
<ul>
<li>开启本地事务</li>
<li>执行事务相关业务</li>
<li>发送消息到MQ</li>
<li>把消息持久化到数据库，标记为已发送</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>事务接收者：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>处理事务相关业务</li>
<li>修改数据库消息状态为已消费</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>额外的定时任务</p>
<ul>
<li>定时扫描表中超时未消费消息，重新发送</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>与tcc相比，实现方式较为简单，开发成本低。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>数据一致性完全依赖于消息服务，因此消息服务必须是可靠的。</p>
</li>
<li><p>需要处理被动业务方的幂等问题</p>
</li>
<li><p>被动业务失败不会导致主动业务的回滚，而是重试被动的业务</p>
</li>
<li><p><strong>事务业务与消息发送业务耦合</strong>、业务数据与消息表要在一起</p>
</li>
</ul>
<h4 id="2）独立消息服务"><a href="#2）独立消息服务" class="headerlink" title="2）独立消息服务"></a>2）独立消息服务</h4><p>为了解决上述问题，我们会引入一个独立的消息服务，来完成对消息的持久化、发送、确认、失败重试等一系列行为，大概的模型如下：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305200131083.png" alt="image-20200305200131083"></p>
<p>一次消息发送的时序图：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305205430863.png" alt="image-20200305205430863"></p>
<p>事务发起者A的基本执行步骤：</p>
<ul>
<li>开启本地事务</li>
<li>通知消息服务，准备发送消息（消息服务将消息持久化，标记为准备发送）</li>
<li>执行本地业务，<ul>
<li>执行失败则终止，通知消息服务，取消发送（消息服务修改订单状态）</li>
<li>执行成功则继续，通知消息服务，确认发送（消息服务发送消息、修改订单状态）</li>
</ul>
</li>
<li>提交本地事务</li>
</ul>
<p>消息服务本身提供下面的接口：</p>
<ul>
<li>准备发送：把消息持久化到数据库，并标记状态为<code>准备发送</code></li>
<li>取消发送：把数据库消息状态修改为<code>取消</code></li>
<li>确认发送：把数据库消息状态修改为<code>确认发送</code>。尝试发送消息，成功后修改状态为<code>已发送</code></li>
<li>确认消费：消费者已经接收并处理消息，把数据库消息状态修改为<code>已消费</code></li>
<li>定时任务：定时扫描数据库中状态为<code>确认发送</code>的消息，然后询问对应的事务发起者，事务业务执行是否成功，结果：<ul>
<li>业务执行成功：<code>尝试发送消息</code>，成功后修改状态为<code>已发送</code></li>
<li>业务执行失败：把数据库消息状态修改为<code>取消</code></li>
</ul>
</li>
</ul>
<p>事务参与者B的基本步骤：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>执行业务</li>
<li>通知消息服务，消息已经接收和处理</li>
<li>提交事务</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>解除了事务业务与消息相关业务的耦合</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实现起来比较复杂</li>
</ul>
<h3 id="2-6-3-RocketMQ事务消息"><a href="#2-6-3-RocketMQ事务消息" class="headerlink" title="2.6.3.RocketMQ事务消息"></a>2.6.3.RocketMQ事务消息</h3><p>RocketMQ本身自带了事务消息，可以保证消息的可靠性，原理其实就是自带了本地消息表，与我们上面讲的思路类似。</p>
<h3 id="2-6-4-RabbitMQ的消息确认"><a href="#2-6-4-RabbitMQ的消息确认" class="headerlink" title="2.6.4.RabbitMQ的消息确认"></a>2.6.4.RabbitMQ的消息确认</h3><p>RabbitMQ确保消息不丢失的思路比较奇特，并没有使用传统的本地表，而是利用了消息的确认机制：</p>
<ul>
<li>生产者确认机制：确保消息从生产者到达MQ不会有问题<ul>
<li>消息生产者发送消息到RabbitMQ时，可以设置一个异步的监听器，监听来自MQ的ACK</li>
<li>MQ接收到消息后，会返回一个回执给生产者：<ul>
<li>消息到达交换机后路由失败，会返回失败ACK</li>
<li>消息路由成功，持久化失败，会返回失败ACK</li>
<li>消息路由成功，持久化成功，会返回成功ACK</li>
</ul>
</li>
<li>生产者提前编写好不同回执的处理方式<ul>
<li>失败回执：等待一定时间后重新发送</li>
<li>成功回执：记录日志等行为</li>
</ul>
</li>
</ul>
</li>
<li>消费者确认机制：确保消息能够被消费者正确消费<ul>
<li>消费者需要在监听队列的时候指定手动ACK模式</li>
<li>RabbitMQ把消息投递给消费者后，会等待消费者ACK，接收到ACK后才删除消息，如果没有接收到ACK消息会一直保留在服务端，如果消费者断开连接或异常后，消息会投递给其它消费者。</li>
<li>消费者处理完消息，提交事务后，手动ACK。如果执行过程中抛出异常，则不会ACK，业务处理失败，等待下一条消息</li>
</ul>
</li>
</ul>
<p>经过上面的两种确认机制，可以确保从消息生产者到消费者的消息安全，再结合生产者和消费者两端的本地事务，即可保证一个分布式事务的最终一致性。</p>
<h3 id="2-6-5-消息事务的优缺点"><a href="#2-6-5-消息事务的优缺点" class="headerlink" title="2.6.5.消息事务的优缺点"></a>2.6.5.消息事务的优缺点</h3><p>总结上面的几种模型，消息事务的优缺点如下：</p>
<ul>
<li>优点：<ul>
<li>相对TCC，代码侵入较少</li>
<li>业务相对简单</li>
<li>是多个本地事务的结合，因此资源锁定周期短，性能好</li>
</ul>
</li>
<li>缺点：<ul>
<li>依赖于MQ的可靠性</li>
<li>消息发起者可以回滚，但是消息参与者无法引起事务回滚</li>
<li>事务时效性差，取决于MQ消息发送是否及时，还有消息参与者的执行情况</li>
</ul>
</li>
</ul>
<p>针对事务无法回滚的问题，有人提出说可以在事务参与者执行失败后，再次利用MQ通知消息服务，然后由消息服务通知其他参与者回滚。那么，恭喜你，你利用MQ和自定义的消息服务再次实现了2PC 模型，又造了一个大轮子</p>
<h2 id="2-7-AT模式"><a href="#2-7-AT模式" class="headerlink" title="2.7.AT模式"></a>2.7.AT模式</h2><p>2019年 1 月份，Seata 开源了 AT 模式。AT 模式是一种<strong>无侵入</strong>的分布式事务解决方案。可以看做是对TCC模型的一种优化，解决了TCC模式中的代码侵入、编码复杂等问题。</p>
<p>在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
<p>可以参考Seata的<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">官方文档</a>。</p>
<h3 id="2-7-1-基本原理"><a href="#2-7-1-基本原理" class="headerlink" title="2.7.1.基本原理"></a>2.7.1.基本原理</h3><p>先来看一张流程图：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305212340203.png" alt="image-20200305212340203"></p>
<p>有没有感觉跟TCC的执行很像，都是分两个阶段：</p>
<ul>
<li>一阶段：执行本地事务，并返回执行结果</li>
<li>二阶段：根据一阶段的结果，判断二阶段做法：提交或回滚</li>
</ul>
<p>但AT模式底层做的事情可完全不同，而且第二阶段根本不需要我们编写，全部由Seata自己实现了。也就是说：我们写的<strong>代码与本地事务时代码一样</strong>，无需手动处理分布式事务。</p>
<p>那么，AT模式如何实现无代码侵入，如何帮我们自动实现二阶段代码的呢？</p>
<blockquote>
<p>一阶段</p>
</blockquote>
<p>在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“<code>业务 SQL</code>”要更新的业务数据，在业务数据被更新前，将其保存成“<code>before image</code>”(<strong>相当于undo log</strong>)，然后执行“<code>业务 SQL</code>”更新业务数据，在业务数据更新之后，再将其保存成“<code>after image</code>”**(相当于undo log)<strong>，最后获取全局行锁，</strong>提交事务**。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305213652558.png" alt="image-20200305213652558"></p>
<blockquote>
<p>二阶段提交</p>
</blockquote>
<p>二阶段如果是提交的话，因为“<code>业务 SQL</code>”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<blockquote>
<p>二阶段回滚：</p>
</blockquote>
<p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“<code>业务 SQL</code>”，还原业务数据。回滚方式便是用“<code>before image</code>”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “<code>after image</code>”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有<code>脏写</code>，<strong>出现脏写就需要转人工处理。</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">脏写：</span></span><br><span class="line">	<span class="meta">事务</span> <span class="string">B 去修改了事务 A 修改过的值，但是此时事务 A 还没提交，</span></span><br><span class="line">	<span class="meta">所以事务</span> <span class="string">A 随时会回滚，导致事务 B 修改的值也没了</span></span><br><span class="line">	</span><br><span class="line">	<span class="attr">所以要校验脏写，如果发生脏写，就不能简单执行A的回滚，而是人工判断，决策！</span></span><br></pre></td></tr></table></figure>



<p>穿插知识点：(脏写、脏读、不可重复读、幻读)</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="string">//zhuanlan.zhihu.com/p/150107974</span></span><br></pre></td></tr></table></figure>



<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305214649845.png" alt="image-20200305214649845"></p>
<p>不过因为有<strong>全局锁机制</strong>，所以可以降低出现<code>脏写</code>的概率。</p>
<p><strong>AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。</strong></p>
<h3 id="2-7-2-详细架构和流程"><a href="#2-7-2-详细架构和流程" class="headerlink" title="2.7.2.详细架构和流程"></a>2.7.2.详细架构和流程</h3><p>Seata中的几个基本概念：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1-</span> <span class="string">TC（Transaction Coordinator） - 事务协调者</span></span><br><span class="line">  <span class="attr">维护全局和分支事务的状态，驱动全局事务提交或回滚（TM之间的协调者）。</span></span><br><span class="line"><span class="meta">2-</span> <span class="string">TM（Transaction Manager） - 事务管理器</span></span><br><span class="line">  <span class="attr">定义全局事务的范围：开始全局事务、提交或回滚全局事务。</span></span><br><span class="line"><span class="meta">3-</span> <span class="string">RM（Resource Manager） - 资源管理器</span></span><br><span class="line">  <span class="attr">管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</span></span><br></pre></td></tr></table></figure>



<p>我们看下面的一个架构图</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305225811888.png" alt="image-20200305225811888"></p>
<ul>
<li>TM：业务模块中全局事务的<code>开启者</code><ul>
<li>向TC开启一个全局事务</li>
<li>调用其它微服务</li>
</ul>
</li>
<li>RM：业务模块执行者中，包含RM部分，负责向TC汇报事务执行状态<ul>
<li>执行本地事务</li>
<li>向TC注册分支事务，并提交本地事务执行结果</li>
</ul>
</li>
<li>TM：结束对微服务的调用，通知TC，全局事务执行完毕，事务一阶段结束</li>
<li>TC：汇总各个分支事务执行结果，决定分布式事务是提交还是回滚；</li>
<li>TC 通知所有 RM 提交/回滚 资源，事务二阶段结束。</li>
</ul>
<p><strong>分两阶段，具体流程如下：</strong></p>
<p>一阶段：</p>
<ul>
<li>TM开启全局事务，并向TC声明全局事务，包括全局事务XID信息</li>
<li>TM所在服务调用其它微服务</li>
<li>微服务，主要有RM来执行<ul>
<li>查询<code>before_image</code></li>
<li>执行本地事务</li>
<li>查询<code>after_image</code></li>
<li>生成<code>undo_log</code>并写入数据库</li>
<li>向TC注册分支事务，告知事务执行结果</li>
<li>获取全局锁（阻止其它全局事务并发修改当前数据）</li>
<li>释放本地锁（不影响其它业务对数据的操作）</li>
</ul>
</li>
<li>待所有业务执行完毕，事务发起者（TM）会尝试向TC提交全局事务</li>
</ul>
<p>二阶段：</p>
<ul>
<li>TC统计分支事务执行情况，根据结果判断下一步行为<ul>
<li>分支都成功：通知分支事务，提交事务</li>
<li>有分支执行失败：通知执行成功的分支事务，”回滚数据”(补偿)</li>
</ul>
</li>
<li>分支事务的RM<ul>
<li>提交事务：直接清空<code>before_image</code>和<code>after_image</code>信息，释放全局锁</li>
<li>回滚事务：<ul>
<li>校验after_image，判断是否有脏写</li>
<li>如果没有脏写，回滚数据到<code>before_image</code>，清除<code>before_image</code>和<code>after_image</code>，释放全局锁</li>
<li>如果有脏写，请求人工介入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-7-3-工作机制"><a href="#2-7-3-工作机制" class="headerlink" title="2.7.3.工作机制"></a>2.7.3.工作机制</h3><p>详见Seata的官方文档：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<blockquote>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4></blockquote>
<p>以一个示例来说明整个 AT 分支的工作过程。</p>
<p>业务表：<code>product</code></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody></table>
<p>AT 分支事务的业务逻辑：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;GTS&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h4></blockquote>
<p>过程：</p>
<ol>
<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = ‘TXC’）等相关的信息。</li>
<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>得到前镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TXC</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>
<li>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>`;</span><br></pre></td></tr></table></figure>

<p>得到后镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GTS</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;branchId&quot;</span>: <span class="number">641789253</span>,</span><br><span class="line">	<span class="attr">&quot;undoItems&quot;</span>: [&#123;</span><br><span class="line">		<span class="attr">&quot;afterImage&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">				<span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;GTS&quot;</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2014&quot;</span></span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;],</span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;beforeImage&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">				<span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;TXC&quot;</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2014&quot;</span></span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;],</span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;sqlType&quot;</span>: <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">	&#125;],</span><br><span class="line">	<span class="attr">&quot;xid&quot;</span>: <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>提交前，向 TC 注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的 <strong>全局锁</strong> 。</li>
<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>
<li>将本地事务提交的结果上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-回滚"><a href="#二阶段-回滚" class="headerlink" title="二阶段-回滚"></a>二阶段-回滚</h4></blockquote>
<ol>
<li>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</li>
<li>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</li>
<li>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</li>
<li>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-提交"><a href="#二阶段-提交" class="headerlink" title="二阶段-提交"></a>二阶段-提交</h4></blockquote>
<ol>
<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>
<li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li>
</ol>
<h3 id="2-7-4-优缺点"><a href="#2-7-4-优缺点" class="headerlink" title="2.7.4.优缺点"></a>2.7.4.优缺点</h3><p>优点：</p>
<ul>
<li>与2PC相比：每个分支事务都是独立提交，不互相等待，减少了资源锁定和阻塞时间</li>
<li>与TCC相比：二阶段的执行操作全部自动化生成，无代码侵入，开发成本低</li>
</ul>
<p>缺点：</p>
<ul>
<li>与TCC相比，需要动态生成二阶段的反向补偿操作，执行性能略低于TCC</li>
</ul>
<h2 id="2-8-Saga模式"><a href="#2-8-Saga模式" class="headerlink" title="2.8.Saga模式"></a>2.8.Saga模式</h2><p>Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</p>
<p>其理论基础是Hector &amp; Kenneth  在1987年发表的论文<a target="_blank" rel="noopener" href="https://microservices.io/patterns/data/saga.html">Sagas</a>。</p>
<p>Seata官网对于Saga的指南：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html">https://seata.io/zh-cn/docs/user/saga.html</a></p>
<h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1561965208439-606129fe-6761-4177-8887-1fda9306f104.png" alt="Saga 模式"> </p>
<p>Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行的，Saga 模式是一种长事务解决方案。</p>
<h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>
<h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>不保证隔离性（应对方案见<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html">用户文档</a>）</li>
</ul>
<h1 id="3-Seata"><a href="#3-Seata" class="headerlink" title="3.Seata"></a>3.Seata</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1.介绍"></a>3.1.介绍</h2><p>Seata（Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架）是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。Seata 开源半年左右，目前已经有接近一万 star，社区非常活跃。我们热忱欢迎大家参与到 Seata 社区建设中，一同将 Seata 打造成开源分布式事务标杆产品。</p>
<p>Seata：<a target="_blank" rel="noopener" href="https://github.com/seata/seata">https://</a><a target="_blank" rel="noopener" href="https://github.com/seata/seata">github.com/seata/seata</a></p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1561960344792-8810110b-1eda-4417-944e-7051ca52f90d.png" alt="Seata"></p>
<h3 id="3-1-1-Seata-产品模块"><a href="#3-1-1-Seata-产品模块" class="headerlink" title="3.1.1. Seata 产品模块"></a>3.1.1. Seata 产品模块</h3><p>如下图所示，Seata 中有三大模块，分别是 TM、RM 和 TC。 其中 TM 和 RM 是作为 Seata 的客户端与业务系统集成在一起，TC 作为 Seata 的服务端独立部署。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305225811888.png" alt="image-20200305225811888"></p>
<h3 id="3-1-2-Seata支持的事务模型"><a href="#3-1-2-Seata支持的事务模型" class="headerlink" title="3.1.2.Seata支持的事务模型"></a>3.1.2.Seata支持的事务模型</h3><p>Seata 会有 4 种分布式事务解决方案，分别是 AT 模式、TCC 模式、Saga 模式和 XA 模式。<img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200305230513415.png" alt="image-20200305230513415"> </p>
<h2 id="3-2-AT模式实战"><a href="#3-2-AT模式实战" class="headerlink" title="3.2.AT模式实战"></a>3.2.AT模式实战</h2><p>Seata中比较常用的是AT模式，这里我们拿AT模式来做演示，看看如何在SpringCloud微服务中集成Seata.</p>
<p>我们假定一个用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1-</span> <span class="string">仓储服务：对给定的商品扣除仓储数量。</span></span><br><span class="line"><span class="meta">2-</span> <span class="string">订单服务：根据采购需求创建订单。</span></span><br><span class="line"><span class="meta">3-</span> <span class="string">帐户服务：从用户帐户中扣除余额。</span></span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306164728739.png" alt="image-20200306164728739"></p>
<p>订单服务在下单时，同时调用库存服务和用户服务，此时就会发生<strong>跨服务和跨数据源的分布式事务</strong>问题。</p>
<h3 id="3-2-1-准备数据"><a href="#3-2-1-准备数据" class="headerlink" title="3.2.1.准备数据"></a>3.2.1.准备数据</h3><p>执行资料中提供的<code>seata_demo.sql</code>文件，导入数据。</p>
<p>其中包含4张表。</p>
<p>Order表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `order_tbl` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id` varchar(255) DEFAULT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">  `commodity_code` varchar(255) DEFAULT NULL COMMENT &#x27;商品码&#x27;,</span><br><span class="line">  `count` int(11) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;购买数量&#x27;,</span><br><span class="line">  `money` int(11) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;总金额&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;</span><br></pre></td></tr></table></figure>

<p>商品库存表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `storage_tbl` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `commodity_code` varchar(255) DEFAULT NULL COMMENT &#x27;商品码&#x27;,</span><br><span class="line">  `count` int(11) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;商品库存&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  UNIQUE KEY `commodity_code` (`commodity_code`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;</span><br></pre></td></tr></table></figure>

<p>用户账户表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `account_tbl` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id` varchar(255) DEFAULT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">  `money` int(11) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;用户余额&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;</span><br></pre></td></tr></table></figure>

<p>还有用来记录Seata中的事务日志表undo_log，其中会包含<code>after_image</code>和<code>before_image</code>数据，用于数据回滚：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `undo_log` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(100) NOT NULL,</span><br><span class="line">  `context` varchar(128) NOT NULL,</span><br><span class="line">  `rollback_info` longblob NOT NULL,</span><br><span class="line">  `log_status` int(11) NOT NULL,</span><br><span class="line">  `log_created` datetime NOT NULL,</span><br><span class="line">  `log_modified` datetime NOT NULL,</span><br><span class="line">  `ext` varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-2-引入Demo工程"><a href="#3-2-2-引入Demo工程" class="headerlink" title="3.2.2.引入Demo工程"></a>3.2.2.引入Demo工程</h3><p>我们先准备基本的项目环境，实现下单的业务代码</p>
<h4 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h4><p>使用Idea打开资料中提供的 seata-demo项目：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306170419354.png" alt="image-20200306170419354"> </p>
<p>找到项目所在目录，选中并打开：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306170520985.png" alt="image-20200306170520985"> </p>
<p>项目结构如下：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306171827203.png" alt="image-20200306171827203"> </p>
<p>结构说明：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1-</span> <span class="string">account-service：用户服务，提供操作用户账号余额的功能，端口8083</span></span><br><span class="line"><span class="meta">2-</span> <span class="string">eureka-server：注册中心，端口8761</span></span><br><span class="line"><span class="meta">3-</span> <span class="string">order-service：订单服务，提供根据数据创建订单的功能，端口8082</span></span><br><span class="line"><span class="meta">4-</span> <span class="string">storage-service：仓储服务，提供扣减商品库存功能，端口8081</span></span><br></pre></td></tr></table></figure>

<h4 id="测试事务"><a href="#测试事务" class="headerlink" title="测试事务"></a>测试事务</h4><p>接下来，我们来测试下分布式事务的现象。</p>
<p>下单的接口是：</p>
<ul>
<li>请求方式：POST</li>
<li>请求路径：/order</li>
<li>请求参数：form表单，包括：<ul>
<li>userId：用户id</li>
<li>commodityCode：商品码</li>
<li>count：购买数量</li>
<li>money：话费金额</li>
</ul>
</li>
<li>返回值类型：long，订单的id</li>
</ul>
<p>原始数据库数据：</p>
<p>余额：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173439268.png" alt="image-20200306173439268"> </p>
<p>库存：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173511332.png" alt="image-20200306173511332"> </p>
<p>其它两张表为空。</p>
<blockquote>
<p>正常下单</p>
</blockquote>
<p>此时启动项目，尝试下单，目前商品库存为10，用户余额为1000，因此只要数据不超过这两个值应该能正常下单。</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173343839.png" alt="image-20200306173343839"> </p>
<p>查看数据库数据：</p>
<p>余额：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173602942.png" alt="image-20200306173602942"> </p>
<p>库存：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173629491.png" alt="image-20200306173629491"> </p>
<p>订单：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173700813.png" alt="image-20200306173700813"> </p>
<blockquote>
<p>异常下单</p>
</blockquote>
<p>这次，我们把money参数设置为1200，这样就超过了余额最大值，理论上所有数据都应该回滚：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173916953.png" alt="image-20200306173916953"></p>
<p>看下用户余额：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306224048175.png" alt="image-20200306224048175"> </p>
<p>因为扣款失败，因此这里没有扣减</p>
<p>来看下库存数据：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306174001901.png" alt="image-20200306174001901"> </p>
<p><strong>这说明扣减库存依然成功，并未回滚！</strong></p>
<p>接下来，我们引入Seata，看看能不能解决这个问题。</p>
<h3 id="3-2-3-准备TC服务"><a href="#3-2-3-准备TC服务" class="headerlink" title="3.2.3.准备TC服务"></a>3.2.3.准备TC服务</h3><p>在之前讲解Seata原理的时候，我们就聊过，其中包含重要的3个角色：</p>
<ul>
<li>TC：事务协调器</li>
<li>TM：事务管理器</li>
<li>RM：资源管理器</li>
</ul>
<p>其中，TC是一个独立的服务，负责协调各个分支事务，而TM和RM通过jar包的方式，集成在各个事务参与者中。</p>
<p>因此，首先我们需要<strong>搭建一个独立的TC服务</strong>。</p>
<h4 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h4><p>首先去官网下载TC的服务端安装包，GitHub的地址：<a target="_blank" rel="noopener" href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p>
<p>这里我们在资料中提供给大家1.1.0版本的安装包：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306174740064.png" alt="image-20200306174740064"> </p>
<p>然后解压即可，其目录结构如下：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306174818712.png" alt="image-20200306174818712"> </p>
<p>包括：</p>
<ul>
<li>bin：启动脚本</li>
<li>conf：配置文件</li>
<li>lib：依赖项</li>
</ul>
<h4 id="2）配置"><a href="#2）配置" class="headerlink" title="2）配置"></a>2）配置</h4><p><strong>Seata的核心配置</strong>主要是两部分：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-</span> <span class="string">1 注册中心的配置：在`$&#123;seata_home&#125;/conf/`目录中，一般是`registry.conf`文件</span></span><br><span class="line"><span class="meta">-</span> <span class="string">2 当前服务的配置，两种配置方式：</span></span><br><span class="line">  <span class="meta">(1)-</span> <span class="string">通过分布式服务的统一配置中心，例如Zookeeper</span></span><br><span class="line">  <span class="meta">(2)-</span> <span class="string">通过本地文件</span></span><br></pre></td></tr></table></figure>



<p>我们先看registry.conf，内容是JSON风格</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # 指定注册中心类型，这里使用eureka类型</span><br><span class="line">  type = <span class="attr">&quot;eureka&quot;</span></span><br><span class="line">  # 各种注册中心的配置。。这里省略，只保留了eureka和Zookeeper</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = <span class="attr">&quot;http://localhost:8761/eureka&quot;</span></span><br><span class="line">    application = <span class="attr">&quot;seata_tc_server&quot;</span></span><br><span class="line">    weight = <span class="attr">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = <span class="attr">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="attr">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.timeout = 6000</span><br><span class="line">    connect.timeout = 2000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # 配置文件方式，可以支持 file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type = <span class="attr">&quot;file&quot;</span></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="attr">&quot;localhost&quot;</span></span><br><span class="line">    namespace = <span class="attr">&quot;&quot;</span></span><br><span class="line">    group = <span class="attr">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = <span class="attr">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.timeout = 6000</span><br><span class="line">    connect.timeout = 2000</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="attr">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件主要配置两个内容：</p>
<ul>
<li><strong>1 注册中心的类型及地址</strong>，本例我们选择eureka做注册中心<ul>
<li>eureka.serviceUrl：是eureka的地址，例如<a target="_blank" rel="noopener" href="http://localhost:8761/eureka">http://localhost:8761/eureka</a></li>
<li>application：是TC注册到eureka时的服务名称，例如<code>seata_tc_server</code></li>
</ul>
</li>
<li><strong>2 配置中心的类型及地址</strong>，本例我们选择本地文件做配置，就是当前目录的<code>file.conf</code>文件</li>
</ul>
<p>再来看<code>file.conf</code>文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">## transaction log store, only used in seata-server</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db</span><br><span class="line">  # 这里好像是用db吧#######</span><br><span class="line">  mode = <span class="string">&quot;file&quot;</span></span><br><span class="line">  ## file store property</span><br><span class="line">  file &#123;</span><br><span class="line">    ## store location dir</span><br><span class="line">    dir = <span class="attr">&quot;sessionStore&quot;</span></span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    maxBranchSessionSize = 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    maxGlobalSessionSize = 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    fileWriteBufferCacheSize = 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    sessionReloadReadSize = 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flushDiskMode = async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store property</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource = <span class="attr">&quot;dbcp&quot;</span></span><br><span class="line">    ## mysql/oracle/h2/oceanbase etc.</span><br><span class="line">    dbType = <span class="attr">&quot;mysql&quot;</span></span><br><span class="line">    driverClassName = <span class="attr">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    url = <span class="attr">&quot;jdbc:mysql://127.0.0.1:3306/seata_demo&quot;</span></span><br><span class="line">    user = <span class="attr">&quot;root&quot;</span></span><br><span class="line">    password = <span class="attr">&quot;123&quot;</span></span><br><span class="line">    minConn = 1</span><br><span class="line">    maxConn = 10</span><br><span class="line">    globalTable = <span class="attr">&quot;global_table&quot;</span></span><br><span class="line">    branchTable = <span class="attr">&quot;branch_table&quot;</span></span><br><span class="line">    lockTable = <span class="attr">&quot;lock_table&quot;</span></span><br><span class="line">    queryLimit = 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键配置：</p>
<ul>
<li>store：TC的服务端数据存储配置<ul>
<li>mode：数据存储方式，支持两种：file和db<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-</span> <span class="string">file：将数据存储在本地文件中，性能比较好，但不支持水平扩展</span></span><br><span class="line"><span class="meta">-</span> <span class="string">db：将数据保存在指定的数据库中，需要指定数据库连接信息</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>如果用文件作为存储介质，不需要其它配置了，直接运行即可。</p>
<p>但是如果使用db作为存储介质，还需要在数据库中<strong>创建3张表</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `global_table`</span><br><span class="line">(</span><br><span class="line">    `xid`                       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`            <span class="type">BIGINT</span>,</span><br><span class="line">    `status`                    TINYINT      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `application_id`            <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_service_group` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_name`          <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `timeout`                   <span class="type">INT</span>,</span><br><span class="line">    `begin_time`                <span class="type">BIGINT</span>,</span><br><span class="line">    `application_data`          <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`                DATETIME,</span><br><span class="line">    `gmt_modified`              DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`xid`),</span><br><span class="line">    KEY `idx_gmt_modified_status` (`gmt_modified`, `status`),</span><br><span class="line">    KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `branch_table`</span><br><span class="line">(</span><br><span class="line">    `branch_id`         <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`               <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`    <span class="type">BIGINT</span>,</span><br><span class="line">    `resource_group_id` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `resource_id`       <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `branch_type`       <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    `status`            TINYINT,</span><br><span class="line">    `client_id`         <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    `application_data`  <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`        DATETIME,</span><br><span class="line">    `gmt_modified`      DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`branch_id`),</span><br><span class="line">    KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `lock_table`</span><br><span class="line">(</span><br><span class="line">    `row_key`        <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`            <span class="type">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">    `transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">    `branch_id`      <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource_id`    <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `table_name`     <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `pk`             <span class="type">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    `gmt_create`     DATETIME,</span><br><span class="line">    `gmt_modified`   DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`row_key`),</span><br><span class="line">    KEY `idx_branch_id` (`branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>



<h4 id="3）启动"><a href="#3）启动" class="headerlink" title="3）启动"></a>3）启动</h4><p>进入<code>$&#123;seata_home&#125;/bin/</code>目录中:</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306201749660.png" alt="image-20200306201749660"> </p>
<p>如果是linux环境（要有JRE），执行<code>seata-server.sh</code></p>
<p>如果是windows环境，执行<code>seata-server.bat</code></p>
<h3 id="3-2-4-改造Order服务"><a href="#3-2-4-改造Order服务" class="headerlink" title="3.2.4.改造Order服务"></a>3.2.4.改造Order服务</h3><p>接下来是微服务的改造，不管是哪一个微服务，只要是事务的参与者，步骤基本一致。</p>
<h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><p>我们在父工程<code>seata-demo</code>中已经对依赖做了管理：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306210054786.png" alt="image-20200306210054786"> </p>
<p>因此，我们在项目<code>order-service</code>的pom文件中，引入依赖坐标即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2）添加配置文件"><a href="#2）添加配置文件" class="headerlink" title="2）添加配置文件"></a>2）添加配置文件</h4><p>首先在application.yml中添加一行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">test_tx_group</span> <span class="comment"># 定义事务组的名称</span></span><br></pre></td></tr></table></figure>

<p>这里是定义事务组的名称，接下来会用到。</p>
<p>然后是在<code>resources</code>目录下放两个配置文件：<code>file.conf</code>和<code>registry.conf</code></p>
<p>其中，<code>registry.conf</code>与TC服务端的一样，此处不再讲解。</p>
<p>我们来看下<code>file.conf</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type = <span class="attr">&quot;TCP&quot;</span></span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server = <span class="attr">&quot;NIO&quot;</span></span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat = true</span><br><span class="line">  # the client batch send request enable</span><br><span class="line">  enableClientBatchSendRequest = true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  threadFactory &#123;</span><br><span class="line">    bossThreadPrefix = <span class="attr">&quot;NettyBoss&quot;</span></span><br><span class="line">    workerThreadPrefix = <span class="attr">&quot;NettyServerNIOWorker&quot;</span></span><br><span class="line">    serverExecutorThread-prefix = <span class="attr">&quot;NettyServerBizHandler&quot;</span></span><br><span class="line">    shareBossWorker = false</span><br><span class="line">    clientSelectorThreadPrefix = <span class="attr">&quot;NettyClientSelector&quot;</span></span><br><span class="line">    clientSelectorThreadSize = 1</span><br><span class="line">    clientWorkerThreadPrefix = <span class="attr">&quot;NettyClientWorkerThread&quot;</span></span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    bossThreadSize = 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    workerThreadSize = <span class="attr">&quot;default&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait = 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization = <span class="string">&quot;seata&quot;</span></span><br><span class="line">  compressor = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">service &#123;</span><br><span class="line">  vgroupMapping.test_tx_group = <span class="attr">&quot;seata_tc_server&quot;</span>  # 必须与注册到注册中心的微服务名称一致</span><br><span class="line">  #only support when registry.type=file, please don&#x27;t set multiple addresses</span><br><span class="line">  seata_tc_server.grouplist = <span class="attr">&quot;127.0.0.1:8091&quot;</span></span><br><span class="line">  #degrade, current not support</span><br><span class="line">  enableDegrade = false</span><br><span class="line">  #disable seata</span><br><span class="line">  disableGlobalTransaction = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  rm &#123;</span><br><span class="line">    asyncCommitBufferLimit = 10000</span><br><span class="line">    lock &#123;</span><br><span class="line">      retryInterval = 10</span><br><span class="line">      retryTimes = 30</span><br><span class="line">      retryPolicyBranchRollbackOnConflict = true</span><br><span class="line">    &#125;</span><br><span class="line">    reportRetryCount = <span class="number">5</span></span><br><span class="line">    tableMetaCheckEnable = <span class="literal">false</span></span><br><span class="line">    reportSuccessEnable = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  tm &#123;</span><br><span class="line">    commitRetryCount = 5</span><br><span class="line">    rollbackRetryCount = 5</span><br><span class="line">  &#125;</span><br><span class="line">  undo &#123;</span><br><span class="line">    dataValidation = true</span><br><span class="line">    logSerialization = <span class="attr">&quot;jackson&quot;</span></span><br><span class="line">    logTable = <span class="attr">&quot;undo_log&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  log &#123;</span><br><span class="line">    exceptionRate = 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置解读：</p>
<ul>
<li><code>transport</code>：与TC交互的一些配置<ul>
<li><code>heartbeat</code>：client和server通信心跳检测开关</li>
<li><code>enableClientBatchSendRequest</code>：客户端事务消息请求是否批量合并发送</li>
</ul>
</li>
<li><code>service</code>：TC的地址配置，用于获取TC的地址<ul>
<li><code>vgroupMapping.test_tx_group = &quot;seata_tc_server&quot;</code>：<ul>
<li><code>test_tx_group</code>：是事务组名称，要与application.yml中配置一致，</li>
<li><code>seata_tc_server</code>：是TC服务端集群的名称，将来通过注册中心获取TC地址</li>
<li><code>enableDegrade</code>：服务降级开关，默认关闭。如果开启，当业务重试多次失败后会放弃全局事务</li>
<li><code>disableGlobalTransaction</code>：全局事务开关，默认false。false为开启，true为关闭</li>
</ul>
</li>
<li><code>default.grouplist</code>：这个当注册中心为file的时候，才用到</li>
</ul>
</li>
<li><code>client</code>：客户端配置<ul>
<li><code>rm</code>：资源管理器配<ul>
<li><code>asynCommitBufferLimit</code>：二阶段提交默认是异步执行，这里指定异步队列的大小</li>
<li><code>lock</code>：全局锁配置<ul>
<li><code>retryInterval</code>：校验或占用全局锁重试间隔，默认10，单位毫秒</li>
<li><code>retryTimes</code>：校验或占用全局锁重试次数，默认30次</li>
<li><code>retryPolicyBranchRollbackOnConflict</code>：分支事务与其它全局回滚事务冲突时锁策略，默认true，优先释放本地锁让回滚成功</li>
</ul>
</li>
<li><code>reportRetryCount</code>：一阶段结果上报TC失败后重试次数，默认5次</li>
</ul>
</li>
<li><code>tm</code>：事务管理器配置<ul>
<li><code>commitRetryCount</code>：一阶段全局提交结果上报TC重试次数，默认1</li>
<li><code>rollbackRetryCount</code>：一阶段全局回滚结果上报TC重试次数，默认1</li>
</ul>
</li>
<li><code>undo</code>：undo_log的配置<ul>
<li><code>dataValidation</code>：是否开启二阶段回滚镜像校验，默认true</li>
<li><code>logSerialization</code>：undo序列化方式，默认Jackson</li>
<li><code>logTable</code>：自定义undo表名，默认是<code>undo_log</code></li>
</ul>
</li>
<li><code>log</code>：日志配置<ul>
<li><code>exceptionRate</code>：出现回滚异常时的日志记录频率，默认100，百分之一概率。回滚失败基本是脏数据，无需输出堆栈占用硬盘空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3）代理DataSource"><a href="#3）代理DataSource" class="headerlink" title="3）代理DataSource"></a>3）代理DataSource</h4><p>Seata的二阶段执行是通过拦截sql语句，分析语义来指定回滚策略，因此需要对DataSource做代理。我们在项目的<code>cn.itcast.order.config</code>包中，添加一个配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProxyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 订单服务中引入了mybatis-plus，所以要使用特殊的SqlSessionFactoryBean</span></span><br><span class="line">        MybatisSqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> MybatisSqlSessionFactoryBean();</span><br><span class="line">        <span class="comment">// 代理数据源</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(<span class="keyword">new</span> DataSourceProxy(dataSource));</span><br><span class="line">        <span class="comment">// 生成SqlSessionFactory</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里因为订单服务使用了mybatis-plus这个框架（这是一个mybatis集成框架，自动生成单表Sql），因此我们需要用mybatis-plus的<code>MybatisSqlSessionFactoryBean</code>代替<code>SqlSessionFactoryBean</code></p>
<p>如果用的是原生的mybatis，请使用<code>SqlSessionFactoryBean</code>。</p>
<h4 id="4）添加事务注解"><a href="#4）添加事务注解" class="headerlink" title="4）添加事务注解"></a>4）添加事务注解</h4><p>给事务发起者<code>order_service</code>的<code>OrderServiceImpl</code>中的<code>create()</code>方法添加<code>@GlobalTransactional</code>注解，开启全局事务：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306223043452.png" alt="image-20200306223043452"></p>
<p>重新启动即可。</p>
<h3 id="3-2-5-改造Storage、Account服务"><a href="#3-2-5-改造Storage、Account服务" class="headerlink" title="3.2.5.改造Storage、Account服务"></a>3.2.5.改造Storage、Account服务</h3><p>与OrderService类似，这里也要经过下面的步骤：</p>
<ul>
<li><p>引入依赖：与order-service一致，略</p>
</li>
<li><p>添加配置文件：与order-service一致，略</p>
</li>
<li><p>代理DataSource，我们的storage-service和account-service都没有用mybatis-plus，所以配置要使用SqlSessionFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProxyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 因为使用的是mybatis，这里定义SqlSessionFactoryBean</span></span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        <span class="comment">// 配置数据源代理</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(<span class="keyword">new</span> DataSourceProxy(dataSource));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>另外，事务注解可以使用<code>@Transactionnal</code>，而不是<code>@GlobalTransactional</code>，事务发起者才需要添加<code>@GlobalTransactional</code>。</p>
<h3 id="3-2-6-测试"><a href="#3-2-6-测试" class="headerlink" title="3.2.6.测试"></a>3.2.6.测试</h3><p>重启所有微服务后，我们再次测试。</p>
<p>目前数据情况：用户余额900，库存为6.</p>
<p>我们试试扣款1200元，那么扣款失败，理论上来说所有数据都会回滚.</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306173916953.png" alt="image-20200306173916953"></p>
<p>看下用户余额：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306224048175.png" alt="image-20200306224048175"> </p>
<p>因为扣款失败，因此这里没有扣减</p>
<p>来看下库存数据：</p>
<p><img src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200306174001901.png" alt="image-20200306174001901"> </p>
<p>减库存依然是6，成功回滚，说明分布式事务生效了！</p>
<h1 id="4-在项目中整合分布式事务（实战）"><a href="#4-在项目中整合分布式事务（实战）" class="headerlink" title="4.在项目中整合分布式事务（实战）"></a>4.在项目中整合分布式事务（实战）</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">高明辉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Jason</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></div><div class="post_share"><div class="social-share" data-image="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%B0%81%E9%9D%A2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="添加微信"/></a><div class="post-qr-code-desc">添加微信</div></li><li class="reward-item"><a href="/img/pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/pay.jpg" alt="付款码"/></a><div class="post-qr-code-desc">付款码</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/03/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%92%8C%E8%AE%A2%E5%8D%95%E6%B8%85%E7%90%86-%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"><img class="prev-cover" src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/16%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%92%8C%E8%AE%A2%E5%8D%95%E6%B8%85%E7%90%86/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">乐优商城项目-延迟队列和订单清理_分布式日志服务、链路追踪</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/03/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img class="next-cover" src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/15%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">乐优商城项目-微信支付-分布式事务</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">1.什么是分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">1.1.本地事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">1.2.分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%B7%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">3.2.1.</span> <span class="toc-text">1）跨数据源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%B7%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">2）跨服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.</span> <span class="toc-text">3）分布式系统的数据一致性问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">4.</span> <span class="toc-text">2.解决分布式事务的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-CAP%E5%AE%9A%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">2.1.CAP定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-Partition-tolerance"><span class="toc-number">4.1.1.</span> <span class="toc-text">2.1.1.Partition tolerance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-Consistency"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.1.2.Consistency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-Availability"><span class="toc-number">4.1.3.</span> <span class="toc-text">2.1.3.Availability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-Consistency-%E5%92%8C-Availability-%E7%9A%84%E7%9F%9B%E7%9B%BE"><span class="toc-number">4.1.4.</span> <span class="toc-text">2.1.4.Consistency 和 Availability 的矛盾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E5%87%A0%E7%82%B9%E7%96%91%E9%97%AE"><span class="toc-number">4.1.5.</span> <span class="toc-text">2.1.5.几点疑问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Base%E7%90%86%E8%AE%BA"><span class="toc-number">4.2.</span> <span class="toc-text">2.2.Base理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-undo%E5%92%8Credo"><span class="toc-number">4.3.</span> <span class="toc-text">2.3.undo和redo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-undo%E6%97%A5%E5%BF%97"><span class="toc-number">4.3.1.</span> <span class="toc-text">2.3.1.undo日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-redo%E6%97%A5%E5%BF%97"><span class="toc-number">4.3.2.</span> <span class="toc-text">2.3.2.redo日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.3.</span> <span class="toc-text">2.3.3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%88%86%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">4.4.</span> <span class="toc-text">2.4.分阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1DTP%E5%92%8CXA"><span class="toc-number">4.4.1.</span> <span class="toc-text">2.4.1DTP和XA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">4.4.2.</span> <span class="toc-text">2.4.2.二阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.4.3.</span> <span class="toc-text">2.4.3.使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-TCC"><span class="toc-number">4.5.</span> <span class="toc-text">2.5.TCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.1.</span> <span class="toc-text">2.5.1.基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">2.5.2.实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E4%BC%98%E5%8A%BF%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">4.5.3.</span> <span class="toc-text">2.5.3.优势和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.4.</span> <span class="toc-text">2.5.4.使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.6.</span> <span class="toc-text">2.6.可靠消息服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.6.1.</span> <span class="toc-text">2.6.1.基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">2.6.2.本地消息表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">1）简化版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%8B%AC%E7%AB%8B%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">2）独立消息服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">4.6.3.</span> <span class="toc-text">2.6.3.RocketMQ事务消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">4.6.4.</span> <span class="toc-text">2.6.4.RabbitMQ的消息确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-5-%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.6.5.</span> <span class="toc-text">2.6.5.消息事务的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-AT%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">2.7.AT模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.1.</span> <span class="toc-text">2.7.1.基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E8%AF%A6%E7%BB%86%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.7.2.</span> <span class="toc-text">2.7.2.详细架构和流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">4.7.3.</span> <span class="toc-text">2.7.3.工作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E6%AE%B5"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">一阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E5%9B%9E%E6%BB%9A"><span class="toc-number">4.7.3.3.</span> <span class="toc-text">二阶段-回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E6%8F%90%E4%BA%A4"><span class="toc-number">4.7.3.4.</span> <span class="toc-text">二阶段-提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.7.4.</span> <span class="toc-text">2.7.4.优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Saga%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">2.8.Saga模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.8.1.</span> <span class="toc-text">基本模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">4.8.2.</span> <span class="toc-text">适用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-number">4.8.3.</span> <span class="toc-text">优势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">4.8.4.</span> <span class="toc-text">缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Seata"><span class="toc-number">5.</span> <span class="toc-text">3.Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">3.1.介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-Seata-%E4%BA%A7%E5%93%81%E6%A8%A1%E5%9D%97"><span class="toc-number">5.1.1.</span> <span class="toc-text">3.1.1. Seata 产品模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-Seata%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">3.1.2.Seata支持的事务模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-AT%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98"><span class="toc-number">5.2.</span> <span class="toc-text">3.2.AT模式实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.1.</span> <span class="toc-text">3.2.1.准备数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%BC%95%E5%85%A5Demo%E5%B7%A5%E7%A8%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">3.2.2.引入Demo工程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">导入项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">测试事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E5%87%86%E5%A4%87TC%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.2.3.准备TC服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%AE%89%E8%A3%85"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">1）安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">2）配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%90%AF%E5%8A%A8"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">3）启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E6%94%B9%E9%80%A0Order%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.2.4.</span> <span class="toc-text">3.2.4.改造Order服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">1）引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">2）添加配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%BB%A3%E7%90%86DataSource"><span class="toc-number">5.2.4.3.</span> <span class="toc-text">3）代理DataSource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.2.4.4.</span> <span class="toc-text">4）添加事务注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E6%94%B9%E9%80%A0Storage%E3%80%81Account%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.2.5.</span> <span class="toc-text">3.2.5.改造Storage、Account服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.6.</span> <span class="toc-text">3.2.6.测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%95%B4%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E5%AE%9E%E6%88%98%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">4.在项目中整合分布式事务（实战）</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 高明辉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Aaee0Vekhg5KbLhMOJQrEU6A-gzGzoHsz',
      appKey: 'mmLHPEEtqvOSJhsqWra8Sq6K',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script type="text/javascript" src="/js/fairyDustCursor.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>