<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>分布式锁 | Jason</title><meta name="keywords" content="分布式锁"><meta name="author" content="高明辉"><meta name="copyright" content="高明辉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0.学习目标 知道什么是分布式锁 知道分布式锁的几种实现方式 知道Redis分布式锁原理 会使用SpringDataRedis执行Lua脚本 掌握Redission的使用  1.SpringSchedule之前我们学习过Quartz这个定时任务框架，功能非常强大，不过我们有时候也会用到一些其它的定时任务框架。 1.1.常见的定时任务框架目前常用的定时任务实现:    实现方式 cron表达式 固定">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式锁">
<meta property="og:url" content="http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/index.html">
<meta property="og:site_name" content="Jason">
<meta property="og:description" content="0.学习目标 知道什么是分布式锁 知道分布式锁的几种实现方式 知道Redis分布式锁原理 会使用SpringDataRedis执行Lua脚本 掌握Redission的使用  1.SpringSchedule之前我们学习过Quartz这个定时任务框架，功能非常强大，不过我们有时候也会用到一些其它的定时任务框架。 1.1.常见的定时任务框架目前常用的定时任务实现:    实现方式 cron表达式 固定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/17%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2022-07-03T02:00:55.000Z">
<meta property="article:modified_time" content="2022-07-03T02:32:40.065Z">
<meta property="article:author" content="高明辉">
<meta property="article:tag" content="分布式锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/17%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%B0%81%E9%9D%A2.png"><link rel="shortcut icon" href="/img/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.png"><link rel="canonical" href="http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-03 10:32:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jason" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">204</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/17%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%B0%81%E9%9D%A2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jason</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-03T02:00:55.000Z" title="发表于 2022-07-03 10:00:55">2022-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-03T02:32:40.065Z" title="更新于 2022-07-03 10:32:40">2022-07-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/">乐优商城项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="分布式锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li>知道什么是分布式锁</li>
<li>知道分布式锁的几种实现方式</li>
<li>知道Redis分布式锁原理</li>
<li>会使用SpringDataRedis执行Lua脚本</li>
<li>掌握Redission的使用</li>
</ul>
<h1 id="1-SpringSchedule"><a href="#1-SpringSchedule" class="headerlink" title="1.SpringSchedule"></a>1.SpringSchedule</h1><p>之前我们学习过Quartz这个定时任务框架，功能非常强大，不过我们有时候也会用到一些其它的定时任务框架。</p>
<h2 id="1-1-常见的定时任务框架"><a href="#1-1-常见的定时任务框架" class="headerlink" title="1.1.常见的定时任务框架"></a>1.1.常见的定时任务框架</h2><p>目前常用的定时任务实现:</p>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>cron表达式</th>
<th>固定时间执行</th>
<th>固定频率执行</th>
<th>开发难易程度</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 的TimeTask</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>复杂</td>
</tr>
<tr>
<td>Spring Schedule</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>简单</td>
</tr>
<tr>
<td>Quartz</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>难</td>
</tr>
</tbody></table>
<p>从以上表格可以看出，Spring Schedule框架功能完善，简单易用。对于中小型项目需求，Spring Schedule是完全可以胜任的。</p>
<h2 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2.简介"></a>1.2.简介</h2><p>Spring Schedule是Spring  Framework的其中一部分功能：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555666217625.png" alt="1555666217625"></p>
<p>并且在SpringBoot中已经默认对Spring的Schedule实现了自动配置，使用时只需要简单注解和部分属性设置即可。</p>
<h2 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3.快速入门"></a>1.3.快速入门</h2><p>我们新建一个Demo工程，完成入门案例的测试：</p>
<h3 id="1-3-1-创建项目"><a href="#1-3-1-创建项目" class="headerlink" title="1.3.1.创建项目"></a>1.3.1.创建项目</h3><p>使用Spring的 initializr来搭建项目：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555667071529.png" alt="1555667071529"></p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555666991890.png" alt="1555666991890"></p>
<p>选择依赖：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555667023874.png" alt="1555667023874"></p>
<h3 id="1-3-2-开启定时任务"><a href="#1-3-2-开启定时任务" class="headerlink" title="1.3.2.开启定时任务"></a>1.3.2.开启定时任务</h3><p>要开启定时任务功能，只需要在启动类上加载一个<code>@EnableScheduling</code>注解即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TaskDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-定义任务"><a href="#1-3-3-定义任务" class="headerlink" title="1.3.3.定义任务"></a>1.3.3.定义任务</h3><p>定义任务，需要散步：</p>
<ul>
<li>声明类，通过<code>@Component</code>注解注册到Spring容器</li>
<li>类中定义方法，方法内部编写任务逻辑</li>
<li>方法上添加注解<code>@Scheduled(fixedRate = 1000)</code>来定义任务执行频率，<ul>
<li>这里的fiexRate=1000，代表是每隔1000毫秒执行一次</li>
</ul>
</li>
</ul>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556163899025.png" alt="1556163899025"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.task.job;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 1000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello spring schedule!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-启动测试"><a href="#1-3-4-启动测试" class="headerlink" title="1.3.4.启动测试"></a>1.3.4.启动测试</h3><p>启动项目，可以在控制台看到任务执行情况：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555667399323.png" alt="1555667399323"></p>
<h2 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4.配置"></a>1.4.配置</h2><p>定时任务有许多可以自定义的配置属性：</p>
<h3 id="1-4-1-任务线程池大小"><a href="#1-4-1-任务线程池大小" class="headerlink" title="1.4.1.任务线程池大小"></a>1.4.1.任务线程池大小</h3><p>默认情况下，定时任务的线程池大小只有1，<strong>当任务较多执行频繁时，会出现阻塞等待的情况</strong>，任务调度器就会出现<strong>时间漂移</strong>，任务执行时间将不确定。</p>
<p>为了避免这样的情况发生，我们需要自定义线程池的大小：</p>
<p>修改application.yml即可实现：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">    <span class="attr">scheduling:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">size:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>重启项目后测试：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555667762439.png" alt="1555667762439"></p>
<p>可以看到执行时会切换到不同的线程执行。</p>
<h3 id="1-4-2-定时策略"><a href="#1-4-2-定时策略" class="headerlink" title="1.4.2.定时策略"></a>1.4.2.定时策略</h3><p>在方法上添加注解<code>@Scheduled</code>可以控制定时执行的频率，有三种策略：</p>
<ul>
<li>fixedRate：按照固定时间频率执行，单位毫秒，即每xx毫秒执行一次。<ul>
<li>如果上一个任务阻塞导致任务积压，则会在当前任务执行后，一次把多个积压的任务都执行完成</li>
<li>举例：假如任务执行每秒1次，而第一个任务执行耗时4秒，会导致4个任务积压，在第一个任务执行后，积压的4个任务会立即执行，不再等待</li>
</ul>
</li>
<li>fixedDelay：固定延迟执行，单位毫秒，即前一个任务执行结束后xx毫秒执行第二个任务。<ul>
<li>如果上一个任务阻塞导致任务积压，则会在当前任务执行后xx毫秒执行下一个任务</li>
</ul>
</li>
<li>cron：知名的cron表达式，使用表达式规则来定义任务执行策略，与fixedDelay类似的。</li>
</ul>
<h3 id="1-4-3-cron表达式"><a href="#1-4-3-cron表达式" class="headerlink" title="1.4.3.cron表达式"></a>1.4.3.cron表达式</h3><p>什么是cron表达式呢？</p>
<p>Cron表达式是一个字符串，字符串包含6或7个域，每一个域代表一个含义，例如秒、分。域和域之间以空格隔开，有如下两种语法格式：</p>
<ul>
<li> Seconds Minutes Hours DayofMonth Month DayofWeek Year</li>
<li> Seconds Minutes Hours DayofMonth Month DayofWeek</li>
</ul>
<p>cron表达式规则：</p>
<table>
<thead>
<tr>
<th>域</th>
<th>允许值</th>
<th>允许的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td>秒（Seconds）</td>
<td>0~59的整数</td>
<td>,   -   *   /</td>
</tr>
<tr>
<td>分（<em>Minutes</em>）</td>
<td>0~59的整数</td>
<td>,   -   *   /</td>
</tr>
<tr>
<td>小时（<em>Hours</em>）</td>
<td>0~23的整数</td>
<td>,   -   *   /</td>
</tr>
<tr>
<td>日期（<em>DayofMonth</em>）</td>
<td>1~31的整数（但是你需要考虑你月的天数）</td>
<td>,   -   *  ?   /  L W C</td>
</tr>
<tr>
<td>月份（<em>Month</em>）</td>
<td>1~12的整数或者 JAN-DEC</td>
<td>,   -   *   /</td>
</tr>
<tr>
<td>星期（<em>DayofWeek</em>）</td>
<td>1~7的整数或者 SUN-SAT （1=SUN）</td>
<td>,   -   *  ?   /  L C  #</td>
</tr>
<tr>
<td>年(可选，留空)（<em>Year</em>）</td>
<td>1970~2099</td>
<td>,   -   *   /</td>
</tr>
</tbody></table>
<p>每个域上一般都是数字，或者指定允许的特殊字符：</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件</td>
</tr>
<tr>
<td>?</td>
<td>只能用在DayofMonth和DayofWeek两个域中的一个。它表示不确定的值</td>
</tr>
<tr>
<td>-</td>
<td>表示范围。例如在Hours域使用5-8，表示从5点、6点、7点、8点各执行一次</td>
</tr>
<tr>
<td>,</td>
<td>表示列出枚举值。例如：在week域使用FRI,SUN，表示星期五和星期六执行</td>
</tr>
<tr>
<td>/</td>
<td>一般用法：x/y，从x开始，每次递增y。如果放在minutes域，5/15，表示每小时的5分钟开始，每隔15分钟一次，即：5分钟、20分钟、35分钟、50分钟时执行</td>
</tr>
<tr>
<td>L</td>
<td>表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayOfMonth中，代表每个月的最后一天。如果是在DayOfWeek域，表示每周最后一天（周六），但是如果是：数字+L，如6L表示每月的 最后一个周五</td>
</tr>
<tr>
<td>W</td>
<td>表示最近的有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。</td>
</tr>
<tr>
<td>LW</td>
<td>两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五</td>
</tr>
<tr>
<td>#</td>
<td>用在DayOfMonth中，确定每个月第几个星期几。例如在4#2，表示某月的第二个星期三（2表示当月的第二周，4表示这周的第4天，即星期三）。</td>
</tr>
</tbody></table>
<p>示例：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>0 0 2 1 * ?  *</code></td>
<td>表示在每月的1日的凌晨2点执行任务</td>
</tr>
<tr>
<td><code>0 15 10 ?  * MON-FRI</code></td>
<td>表示周一到周五每天上午10:15执行作</td>
</tr>
<tr>
<td><code>0 15 10 ? * 6L 2002-2006</code></td>
<td>表示2002-2006年的每个月的最后一个星期五上午10:15执行</td>
</tr>
<tr>
<td><code>0 0 9-21 * * 2-7</code></td>
<td>996</td>
</tr>
</tbody></table>
<p>我们把代码修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/2 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello spring schedule!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555684079046.png" alt="1555684079046"></p>
<h1 id="2-认识分布式锁"><a href="#2-认识分布式锁" class="headerlink" title="2.认识分布式锁"></a>2.认识分布式锁</h1><p>在讨论分布式锁前，我们先假设一个业务场景：</p>
<h2 id="2-1-业务场景"><a href="#2-1-业务场景" class="headerlink" title="2.1.业务场景"></a>2.1.业务场景</h2><p>我们在订单服务中开启一个定时任务，每隔一段时间扫描超时未支付订单，然后完成订单清理。</p>
<p>在这个定时任务中，需要完成的业务步骤主要包括：</p>
<ol>
<li>查询超时未支付订单，获取订单中商品信息</li>
<li>修改这些未支付订单的状态，为已关闭</li>
<li>恢复订单中商品扣减的库存</li>
</ol>
<p>如图：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566123763031.png" alt="1566123763031"></p>
<p>因为订单服务可能是一个包含多节点的集群，例如包含10台订单微服务，那么并发时可能发生这样的事情：</p>
<ul>
<li>订单服务A执行了步骤1，但还没有执行步骤2</li>
<li>订单服务B执行了步骤1，于是查询到了与订单服务A查询到的一样的数据</li>
<li>订单服务A执行步骤2和3，此时订单中对应商品的库存已经恢复了</li>
<li>订单服务B也执行了步骤2和步骤3，此时订单中对应商品的库存再次被增加</li>
<li>库存被错误的恢复了多次，==事实上只需要执行一次就可以了==。</li>
</ul>
<p>就像这样：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566124881345.png" alt="1566124881345"></p>
<p>因为任务的并发执行，出现了线程安全问题，商品库存被错误的增加了多次，你能想到解决办法吗？</p>
<h2 id="2-2-为什么需要分布式锁"><a href="#2-2-为什么需要分布式锁" class="headerlink" title="2.2.为什么需要分布式锁"></a>2.2.为什么需要分布式锁</h2><p>对于线程安全问题，我们都很熟悉了，传统的解决方案就是对线程操作资源的代码加锁。如图：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566124938467.png" alt="1566124938467"></p>
<p>理想状态下，加了锁以后，在当前订单服务执行时，其它订单服务需要等待当前订单服务完成业务后才能执行，这样就避免了线程安全问题的发生。</p>
<p>但是，这样真的能解决问题吗？</p>
<p>答案时否定的，为什么呢。</p>
<h3 id="2-2-1-线程锁"><a href="#2-2-1-线程锁" class="headerlink" title="2.2.1.线程锁"></a>2.2.1.线程锁</h3><p>我们通常使用的synchronized或者Lock都是线程锁，对同一个JVM进程内的多个线程有效。因为锁的本质是内存中存放一个标记，记录获取锁的线程时谁，<strong>这个标记对每个线程都可见</strong>。</p>
<ul>
<li>获取锁：就是判断标记中是否已经有线程存在，如果有，则获取锁失败，如果没有，在标记中记录当前线程</li>
<li>释放锁：就是删除标记中保存的线程，并唤醒等待队列中的其它线程</li>
</ul>
<p>因此，锁生效的前提是：</p>
<ul>
<li>互斥：锁的标记只有一个线程可以获取</li>
<li>共享：标记对所有线程可见</li>
</ul>
<p>然而我们启动的多个订单服务，就是多个JVM，内存中的锁显然是不共享的，每个JVM进程都有自己的锁，自然无法保证线程的互斥了，如图：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566133423058.png" alt="1566133423058"></p>
<p>要解决这个问题，就必须保证各个订单服务能够共享内存中的锁标记，此时，分布式锁就闪亮登场了！</p>
<h3 id="2-2-2-分布式锁"><a href="#2-2-2-分布式锁" class="headerlink" title="2.2.2.分布式锁"></a>2.2.2.分布式锁</h3><p>线程锁时一个多线程可见的内存标记，保证同一个任务，同一时刻只能被多线程中的某一个执行。但是这样的锁在分布式系统中，多进程环境下， 就达不到预期的效果了。</p>
<p>而如果我们==将这个标记变成多进程可见，保证这个任务同一时刻只能被多个进程中的某一个执行，那这样的锁就是分布式锁==了。</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566135914594.png" alt="1566135914594"></p>
<p>分布式锁实现有多种方式，其原理都基本类似，只要满足下列要求即可：</p>
<ul>
<li><strong>多进程可见</strong>：多进程可见，否则就无法实现分布式效果</li>
<li><strong>互斥</strong>：同一时刻，只能有一个进程获得锁，执行任务后释放锁</li>
<li>可重入（可选）：同一个任务再次获取改锁不会被死锁</li>
<li>阻塞锁（可选）：获取失败时，具备重试机制，尝试再次获取锁</li>
<li>性能好（可选）：效率高，应对高并发场景</li>
<li>高可用：避免锁服务宕机或处理好宕机的补救措施</li>
</ul>
<p>常见的分布式锁实现方案包括：==基于数据库实现、基于缓存(redis)实现、基于zookeeper==等.</p>
<h1 id="3-Redis实现分布式锁"><a href="#3-Redis实现分布式锁" class="headerlink" title="3.Redis实现分布式锁"></a>3.Redis实现分布式锁</h1><p>按照上面的分析，实现分布是锁要满足五点：多进程可见，互斥，可重入，阻塞，高性能，高可用等。我们来看看Redis如何满足这些需求。</p>
<h2 id="3-1-版本1-基本实现"><a href="#3-1-版本1-基本实现" class="headerlink" title="3.1.版本1-基本实现"></a>3.1.版本1-基本实现</h2><p>第一次尝试，我们先关注其中必须满足的2个条件：</p>
<ul>
<li>多进程可见</li>
<li>互斥，锁可释放</li>
</ul>
<p>1）多进程可见</p>
<p>首先Redis本身就是基于JVM之外的，因此满足多进程可见的要求。</p>
<p>2）互斥</p>
<p>互斥就是说只能有一个进程获取锁标记，这个我们可以基于Redis的setnx指令来实现。setnx是set when not exits的意思。当多次执行setnx命令时，只有第一次执行的才会成功并返回1，其它情况返回0：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1555935393771.png" alt="1555935393771"> </p>
<p>多个进程来对同一个key执行setnx操作，肯定只有一个能执行成功，其它一定会失败，满足了互斥的需求。</p>
<p>3）释放锁</p>
<p>释放锁其实只需要把锁的key删除即可，使用del xxx指令。不过，仔细思考，如果在我们执行del之前，服务突然宕机，那么锁岂不是永远无法删除了？！</p>
<p>为了避免因服务宕机引起锁无法释放问题，我们可以在获取锁的时候，给锁加一个有效时间，当时间超出时，就会自动释放锁，这样就不会死锁了。</p>
<p>但时setnx指令没有设置时间的功能，我们要借助于set指令，然后结合set的 NX和PX参数来完成。</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566136982277.png" alt="1566136982277"> </p>
<p>其中可以指定这样几个参数：</p>
<ul>
<li>EX：过期时长，单位是秒</li>
<li>PX：过期时长，单位是毫秒</li>
<li>NX：等同于setnx</li>
</ul>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566137261107.png" alt="1566137261107"></p>
<p>因此，获取和释放锁的基本流程如图：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566138388369.png" alt="1566138388369"></p>
<p>步骤如下：</p>
<ul>
<li>1、通过set命令设置锁</li>
<li>2、判断返回结果是否是OK<ul>
<li>1）Nil，获取失败，结束或重试（自旋锁）</li>
<li>2）OK，获取锁成功<ul>
<li>执行业务</li>
<li>释放锁，DEL 删除key即可</li>
</ul>
</li>
</ul>
</li>
<li>3、异常情况，服务宕机。超时时间EX结束，会自动释放锁</li>
</ul>
<h2 id="3-2-版本2-互斥性"><a href="#3-2-版本2-互斥性" class="headerlink" title="3.2.版本2-互斥性"></a>3.2.版本2-互斥性</h2><p>刚才的初级版本中，会有一定的安全问题。</p>
<h3 id="3-2-1-问题分析"><a href="#3-2-1-问题分析" class="headerlink" title="3.2.1.问题分析"></a>3.2.1.问题分析</h3><p>大家思考一下，释放锁就是用DEL语句把锁对应的key给删除，有没有这么一种可能性：</p>
<ol>
<li>3个进程：A和B和C，在执行任务，并争抢锁，此时A获取了锁，并设置自动过期时间为10s</li>
<li>A开始执行业务，因为某种原因，业务阻塞，耗时超过了10秒，此时锁自动释放了</li>
<li>B恰好此时开始尝试获取锁，因为锁已经自动释放，成功获取锁</li>
<li>A此时业务执行完毕，执行释放锁逻辑（删除key），于是B的锁被释放了，而B其实还在执行业务</li>
<li>此时进程C尝试获取锁，也成功了，因为A把B的锁删除了。</li>
</ol>
<p>问题出现了：B和C同时获取了锁，违反了互斥性！</p>
<p>如何解决这个问题呢？我们应该在删除锁之前，判断这个锁是否是自己设置的锁，如果不是（例如自己的锁已经超时释放），那么就不要删除了。</p>
<h3 id="3-2-2-解决思路"><a href="#3-2-2-解决思路" class="headerlink" title="3.2.2.解决思路"></a>3.2.2.解决思路</h3><p>那么问题来了：<strong>如何得知当前获取锁的是不是自己</strong>呢？</p>
<p>我们可以在set 锁时，存入当前线程的唯一标识！删除锁前，判断下里面的值是不是与自己标识释放一致，如果不一致，说明不是自己的锁，就不要删除了。</p>
<p>流程如图：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566138838868.png" alt="1566138838868"></p>
<h3 id="3-2-3-代码实现"><a href="#3-2-3-代码实现" class="headerlink" title="3.2.3.代码实现"></a>3.2.3.代码实现</h3><p>我们创建一个SpringBoot项目，引入一些依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在application.yml中指定redis地址：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">ly-redis</span></span><br></pre></td></tr></table></figure>



<p>首先定义一个锁接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true: 获取锁成功， false：获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> releaseTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.BooleanUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String VALUE_PREFIX = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRedisLock</span><span class="params">(String key, StringRedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> releaseTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程的锁标示</span></span><br><span class="line">        String value = VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        Boolean boo = redisTemplate.opsForValue().setIfAbsent(key, value, releaseTime, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">return</span> BooleanUtils.isTrue(boo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程的锁标示</span></span><br><span class="line">        String value = VALUE_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取redis中的锁标示</span></span><br><span class="line">        String cacheValue = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 比较</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.equals(value, cacheValue))&#123;</span><br><span class="line">            <span class="comment">// 一致，是自己的锁，删除</span></span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来，定义一个锁工厂，方便用户获取锁对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLockFactory</span><span class="params">(StringRedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRedisLock <span class="title">getSimpleRedisLock</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleRedisLock(key, redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后编写一个单元测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.demo.lock.RedisLockFactory;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.demo.lock.SimpleRedisLock;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁对象</span></span><br><span class="line">    <span class="keyword">private</span> SimpleRedisLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockTask</span><span class="params">(RedisLockFactory factory)</span> </span>&#123;</span><br><span class="line">        lock = factory.getSimpleRedisLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/10 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">boolean</span> isLock = lock.tryLock(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 判断是否成功</span></span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，任务终止</span></span><br><span class="line">            log.error(<span class="string">&quot;获取锁失败，任务结束！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁成功，开始执行任务</span></span><br><span class="line">            log.info(<span class="string">&quot;获取锁成功，开始执行业务&quot;</span>);</span><br><span class="line">            clearOrder();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;任务执行结束，释放锁&quot;</span>);</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 默认任务延迟</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同时启动项目的两个副本：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\image-20200513110915720.png" alt="image-20200513110915720"> </p>
<p>可以看到定时任务会实现互斥效果。</p>
<h2 id="3-3-版本3-重入性（了解）"><a href="#3-3-版本3-重入性（了解）" class="headerlink" title="3.3.版本3-重入性（了解）"></a>3.3.版本3-重入性（了解）</h2><p>接下来我们来看看分布式锁的第三个特性，重入性。</p>
<p>如果我们在获取锁以后，执行代码的过程中，再次尝试获取锁，执行setnx肯定会失败，因为锁已经存在了。这样有可能导致死锁，这样的锁就是<strong>不可重入</strong>的。</p>
<p>如何解决呢？</p>
<p>当然是想办法改造成<strong>可重入锁</strong>。</p>
<h3 id="3-4-1-重入锁"><a href="#3-4-1-重入锁" class="headerlink" title="3.4.1.重入锁"></a>3.4.1.重入锁</h3><p>什么叫做可重入锁呢？</p>
<blockquote>
<p>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。换一种说法：<strong>同一个线程再次进入同步代码时，可以使用自己已获取到的锁。</strong></p>
</blockquote>
<p>可重入锁可以避免因同一线程中多次获取锁而导致死锁发生。</p>
<p>那么，如何实现可重入锁呢？</p>
<ul>
<li>获取锁：首先尝试获取锁，如果获取失败，<strong>判断这个锁是否是自己的，如果是则允许再次获取</strong>，而且必须记录重复获取锁的次数。</li>
<li>释放锁：释放锁不能直接删除了，因为锁是可重入的，如果锁进入了多次，在最内层直接删除锁，导致外部的业务在没有锁的情况下执行，会有安全问题。因此必须<strong>获取锁时累计重入的次数，释放时则减去重入次数，如果减到0，则可以删除锁</strong>.</li>
</ul>
<p>因此，存储在锁中的信息就必须包含：key、线程标识、重入次数。不能再使用简单的key-value结构，这里推荐使用hash结构：</p>
<ul>
<li>key：lock</li>
<li>hashKey：线程信息</li>
<li>hashValue：重入次数，默认1</li>
</ul>
<h3 id="3-4-2-流程图"><a href="#3-4-2-流程图" class="headerlink" title="3.4.2.流程图"></a>3.4.2.流程图</h3><p>需要用到的一些Redis命令包括：</p>
<ul>
<li>EXISTS key：判断一个Key是否存在</li>
<li>HEXISTS key field：判断一个hash的field是否存在</li>
<li>HSET key field value ：给一个hash的field设置一个值</li>
<li>HINCRBY key field increment：给一个hash的field值增加指定数值</li>
<li>EXPIRE key seconds：给一个key设置过期时间</li>
<li>DEL key：删除指定key</li>
</ul>
<p>具体流程如图：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556164092317.png" alt="1556164092317"></p>
<p>下面我们假设锁的key为“<code>lock</code>”，hashKey是当前线程的id：“<code>threadId</code>”，锁自动释放时间假设为20</p>
<p>获取锁的步骤：</p>
<ul>
<li>1、判断lock是否存在 <code>EXISTS lock</code><ul>
<li>存在，说明有人获取锁了，下面判断是不是自己的锁<ul>
<li>判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li>
<li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤3</li>
</ul>
</li>
</ul>
</li>
<li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li>
<li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>释放锁的步骤：</p>
<ul>
<li>1、判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经失效，不用管了</li>
<li>存在，说明锁还在，重入次数减1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li>
</ul>
</li>
<li>2、判断重入次数是否为0：<ul>
<li>为0，说明锁全部释放，删除key：<code>DEL lock</code></li>
<li>大于0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<h2 id="3-4-Lua脚本"><a href="#3-4-Lua脚本" class="headerlink" title="3.4.Lua脚本"></a>3.4.Lua脚本</h2><p>上面探讨的Redis锁实现方案都忽略了一个非常重要的问题：<strong>原子性</strong>问题。无论是获取锁，还是释放锁的过程，都是有多行Redis指令来完成的，如果不能保证这些Redis命令执行的原子性，则整个过程都是不安全的。</p>
<p>而Redis中支持以Lua脚本来运行多行命令，并且保证整个脚本运行的原子性。</p>
<p>接下来，我们分几块来学习Lua脚本的使用：</p>
<ul>
<li>Redis中如何执行Lua脚本</li>
<li>Lua脚本的基本语法</li>
<li>编写上述分布式锁对应的Lua脚本</li>
</ul>
<h3 id="3-4-1-Redis中如何执行Lua脚本"><a href="#3-4-1-Redis中如何执行Lua脚本" class="headerlink" title="3.4.1.Redis中如何执行Lua脚本"></a>3.4.1.Redis中如何执行Lua脚本</h3><p>与操作Lua相关的命令如下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>EVAL script numkeys key [key ...] arg [arg ...]</code> 执行 Lua 脚本。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</code>  执行 Lua 脚本。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>SCRIPT EXISTS script [script ...] </code> 查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>SCRIPT FLUSH</code>  从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>SCRIPT KILL</code>  杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><code>SCRIPT LOAD script</code>  将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody></table>
<p>其中我们会用到的几个：</p>
<blockquote>
<p>EVAL命令：</p>
</blockquote>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556029159652.png" alt="1556029159652"> </p>
<p>直接执行一段脚本，参数包括：</p>
<ul>
<li>script：脚本内容，或者脚本地址</li>
<li>numkeys：脚本中用到的key的数量，接下来的numkeys个参数会作为key参数，剩下的作为arg参数</li>
<li>key：作为key的参数，会被存入脚本环境中的KEYS数组，角标从1开始</li>
<li>arg：其它参数，会被存入脚本环境中的ARGV数组，角标从1开始</li>
</ul>
<p>示例：<code>EVAL &quot;return &#39;hello world!&#39;&quot; 0</code>，其中：</p>
<ul>
<li><code>&quot;return &#39;hello world!&#39;&quot;</code>：就是脚本的内容，直接返回字符串，没有别的命令</li>
<li><code>0</code>：就是说没有用key参数，直接返回</li>
</ul>
<p>效果：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556030139226.png" alt="1556030139226"> </p>
<blockquote>
<p>SCRIPT LOAD命令</p>
</blockquote>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556029464469.png" alt="1556029464469"> </p>
<p>将一段脚本编译并缓存起来，生成一个SHA1值并返回，作为脚本字典的key，方便下次使用。</p>
<p>参数script就是脚本内容或地址。</p>
<p>以之前案例中的的脚本为例：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556030196610.png" alt="1556030196610"> </p>
<p>此处返回的<code>ada0bc9efe2392bdcc0083f7f8deaca2da7f32ec</code>就是脚本缓存后得到的sha1值。</p>
<p>在脚本字典中，每一个这样的sha1值，对应一段解析好的脚本：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556030293491.png" alt="1556030293491"> </p>
<blockquote>
<p>EVALSHA 命令：</p>
</blockquote>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556029524238.png" alt="1556029524238"> </p>
<p>与EVAL类似，执行一段脚本，区别是通过脚本的sha1值，去脚本缓存中查找，然后执行，参数：</p>
<ul>
<li>sha1：就是脚本对应的sha1值</li>
</ul>
<p>我们用刚刚缓存的脚本为例：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556030354363.png" alt="1556030354363"> </p>
<h3 id="3-4-2-Lua脚本的基本语法"><a href="#3-4-2-Lua脚本的基本语法" class="headerlink" title="3.4.2.Lua脚本的基本语法"></a>3.4.2.Lua脚本的基本语法</h3><p>Lua的详细语法大家可以参考网站上的一些教学，例如：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">Lua菜鸟教程</a>，任何语言都是从基本的如：变量、数据类型、循环、逻辑判断、运算、数组等入手。相信熟悉java的你应该可以快速上手Lua。</p>
<p>我们的分布式锁脚本中，主要用到的是对Redis指令的调用，还有<code>if ... else</code>这样的逻辑判断，再加上一些变量声明等。因此我们从这几块入手，看一些简单命令即可：</p>
<p>1）变量声明</p>
<p>声明一个局部变量，用local关键字即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>2）打印结果</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>3）条件控制</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">2</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>4）循环语句：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( <span class="literal">true</span> )</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;循环将永远执行下去&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>注意，使用break可以跳出循环。</p>
<p>大家能否利用上述语法编写一个猜数字的小游戏？</p>
<p>提示：<code>io.read(&quot;*num&quot;)</code>可以用来读取一个用户输入的数字</p>
<p>代码示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;请输入一个数字:&#x27;</span>)</span><br><span class="line">  <span class="keyword">local</span> a = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;*num&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">100</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;太大了&#x27;</span>)</span><br><span class="line">  <span class="keyword">elseif</span>(a &lt; <span class="number">100</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;太小了&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bingo!猜对了!&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566354008626.png" alt="1566354008626"> </p>
<p>5）Lua调用Redis指令</p>
<p>当我们再Redis中允许Lua脚本时，有一个内置变量redis，并且具备两个函数：</p>
<ul>
<li><code>redis.call(&quot;命令名称&quot;, 参数1， 参数2 ...)</code>: 执行指定的redis命令，执行遇到错误会直接返回错误</li>
<li><code>redis.pcall(&quot;命令名称&quot;, 参数1， 参数2 ...)</code>: 执行指定的redis命令，执行遇到错误会错误以Lua表的形式返回</li>
</ul>
<p>例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, <span class="string">&#x27;num&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这行Lua脚本的含义就是执行Redis命令：<code>set num 123</code></p>
<p>不过，我们编写脚本时并不希望把set后面的key和value写死，而是可以由调用脚本的人来指定，把key和value作为参数传入脚本中执行。</p>
<p>还记得redis中的EVAL命令吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>

<p>EVAL执行脚本时可以接受参数，key和arg，并且会用两个内置变量（数组格式）来接受用户传入的key和arg参数：</p>
<ul>
<li>KEYS：用来存放key参数</li>
<li>ARGV：用来存放除Key以外的参数</li>
</ul>
<p>我们在脚本中，可以从数组中根据角标（Lua中数组角标时从1开始）取出用户传入的参数，像这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>



<p>而后，我们在执行脚本时可以动态指定key及需要存放的value值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return redis.call(&#x27;SET&#x27;, KEYS[1], ARGV[1])&quot; 1 num 666</span><br></pre></td></tr></table></figure>

<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566355223209.png" alt="1566355223209"></p>
<h3 id="3-4-3-编写分布式锁的Lua脚本"><a href="#3-4-3-编写分布式锁的Lua脚本" class="headerlink" title="3.4.3.编写分布式锁的Lua脚本"></a>3.4.3.编写分布式锁的Lua脚本</h3><p>接下来，我们就可以将上面的分布式锁思路用Lua脚本来实现了。</p>
<h4 id="1）普通互斥锁"><a href="#1）普通互斥锁" class="headerlink" title="1）普通互斥锁"></a>1）普通互斥锁</h4><p>先看版本2的实现：</p>
<ul>
<li>获取锁：直接使用客户端的set nx ex 命令即可，无需脚本</li>
<li>释放锁：因为要判断锁中的标识是否时自己的，因此需要脚本，如下：</li>
</ul>
<p>长的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 知道当前线程的锁标示</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 知道锁的key</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据锁的key，获取标示</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, key)</span><br><span class="line"><span class="comment">-- 与指定的标示比较是否一致</span></span><br><span class="line"><span class="keyword">if</span> (id == threadId) <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 如果一致，就删除</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>简化的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断锁是否是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 是则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不是则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参数的含义说明：</p>
<ul>
<li>KEYS[1]：就是锁的key，比如”lock”</li>
<li>ARGV[1]：就是线程的唯一标识，可以时随机字符串</li>
</ul>
<h4 id="2）可重入锁："><a href="#2）可重入锁：" class="headerlink" title="2）可重入锁："></a>2）可重入锁：</h4><p>首先是获取锁：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否存在</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">-- 锁已经存在，判断threadId是否是自己	</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁，重入次数+1</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<p>然后是释放锁：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>); <span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime); <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key); <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-Redis客户端调用Lua"><a href="#3-5-Redis客户端调用Lua" class="headerlink" title="3.5.Redis客户端调用Lua"></a>3.5.Redis客户端调用Lua</h2><p>脚本编写完成，还需要通过客户端来调用lua脚本，封装一个获取锁和释放锁的工具。</p>
<p>首先我们创建一个工程：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566364767687.png" alt="1566364767687"></p>
<p>填写信息：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566364941610.png" alt="1566364941610"></p>
<p>选择依赖：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566364993949.png" alt="1566364993949"></p>
<p>在配置文件中引入Redis的地址信息(注意修改成你自己的redis地址)：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.206.99</span></span><br></pre></td></tr></table></figure>





<h3 id="3-5-1-锁接口"><a href="#3-5-1-锁接口" class="headerlink" title="3.5.1.锁接口"></a>3.5.1.锁接口</h3><p>首先定义一个锁接口，定义锁中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releaseTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> releaseTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-实现类"><a href="#3-5-2-实现类" class="headerlink" title="3.5.2.实现类"></a>3.5.2.实现类</h3><p>我们通过Spring提供的RedisTemplate来操作lua脚本，<code>RedisTemplate</code>中提供了一个方法，用来执行Lua脚本：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556162076875.png" alt="1556162076875"></p>
<p>包含3个参数：</p>
<ul>
<li><code>RedisScript&lt;T&gt; script</code>：封装了Lua脚本的对象</li>
<li><code>List&lt;K&gt; keys</code>：脚本中的key的值</li>
<li><code>Object ... args</code>：脚本中的参数的值</li>
</ul>
<p>因此，要执行Lua脚本，我们需要先把脚本封装到<code>RedisScript</code>对象中，有两种方式来构建<code>RedisScript</code>对象：</p>
<p>1）通过RedisScript中的静态方法：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556162311151.png" alt="1556162311151"></p>
<p>这个方法接受两个参数：</p>
<ul>
<li><code>String script</code>：Lua脚本</li>
<li><code>Class&lt;T&gt; resultType</code>：返回值类型</li>
</ul>
<p>需要把脚本内容写到代码中，作为参数传递，不够优雅。</p>
<p>2）自己创建DefaultRedisScript</p>
<p>另一种方式，就是自己去创建<code>RedisScript</code>的实现类<code>DefaultRedisScript</code>的对象：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556162540499.png" alt="1556162540499"></p>
<p>可以把脚本文件写到classpath下的某个位置，然后通过加载这个文件来获取脚本内容，并设置给<code>DefaultRedisScript</code>实例。</p>
<p>此处我们选择方式二，方便后期对脚本文件的维护。</p>
<p>首先在classpath中编写两个Lua脚本文件.</p>
<p>然后编写一个新的RedisLock实现：ReentrantRedisLock，利用静态代码块来加载脚本并初始化：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566365327191.png" alt="1566365327191"> </p>
<p>其中，加载脚本文件的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantRedisLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line">    <span class="comment">// 释放锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Object&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载获取锁的脚本</span></span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setScriptSource(</span><br><span class="line">            <span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setScriptSource(</span><br><span class="line">            <span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;unlock.lua&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其它代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现RedisLock接口，实现其中的抽象方法，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.support.ResourceScriptSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantRedisLock</span> <span class="keyword">implements</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设定好锁对应的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存入的线程信息的前缀，防止与其它JVM中线程信息冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ID_PREFIX = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Object&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;unlock.lua&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁释放时间</span></span><br><span class="line">    <span class="keyword">private</span> String releaseTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> releaseTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录释放时间</span></span><br><span class="line">        <span class="keyword">this</span>.releaseTime = String.valueOf(releaseTime);</span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        Long result = redisTemplate.execute(</span><br><span class="line">                LOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId(), <span class="keyword">this</span>.releaseTime);</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result.intValue() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        redisTemplate.execute(</span><br><span class="line">                UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId(), <span class="keyword">this</span>.releaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-3-获取锁的工厂"><a href="#3-5-3-获取锁的工厂" class="headerlink" title="3.5.3.获取锁的工厂"></a>3.5.3.获取锁的工厂</h3><p>定义一个工厂，用来生成锁对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisLock <span class="title">getReentrantLock</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReentrantRedisLock(redisTemplate, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-4-测试"><a href="#3-5-4-测试" class="headerlink" title="3.5.4.测试"></a>3.5.4.测试</h3><p>我们定义一个定时任务，模拟清理订单的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.demo.lock.RedisLock;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.demo.lock.RedisLockFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClearOrderTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLockFactory redisLockFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/10 * * ? * *&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearOrderTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        clearOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearOrder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始清理未支付订单!&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        log.info(<span class="string">&quot;恢复数据库库存！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们给任务加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClearOrderTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLockFactory redisLockFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/10 * * ? * *&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearOrderTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁对象</span></span><br><span class="line">        RedisLock lock = redisLockFactory.getReentrantLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试加锁</span></span><br><span class="line">        <span class="keyword">boolean</span> isLock = lock.tryLock(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 判断是否成功</span></span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，结束任务</span></span><br><span class="line">            log.error(<span class="string">&quot;获取锁失败，任务终止！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取锁成功，开始执行任务&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            clearOrder();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            log.warn(<span class="string">&quot;任务结束，释放锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearOrder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始清理未支付订单!&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        log.info(<span class="string">&quot;恢复数据库库存！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将启动项复制2份（或多分），测试锁是否能生效：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566365847213.png" alt="1566365847213"> </p>
<p>修改第二个启动项的端口，避免冲突</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566365918528.png" alt="1566365918528"></p>
<p>同时启动2个启动项，查看日志：</p>
<p>第一个服务：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566366085319.png" alt="1566366085319"></p>
<p>第二个服务：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566366093929.png" alt="1566366093929"></p>
<p>可以看到：</p>
<ul>
<li>在13:39:50秒时，8081服务获取锁失败，而8082服务获取锁成功</li>
<li>在13:40:00秒时，8082服务获取锁失败，而8081服务获取锁成功</li>
</ul>
<h2 id="3-6-Redisson"><a href="#3-6-Redisson" class="headerlink" title="3.6.Redisson"></a>3.6.Redisson</h2><p>如果按照Redlock算法来实现分布式锁，加上各种安全控制，代码会比较复杂。而开源的Redission框架就帮我们实现了各种基于Redis的分布式锁，包括Redlock锁。</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(<code>BitSet</code>, <code>Set</code>, <code>Multimap</code>, <code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>BlockingQueue</code>, <code>Deque</code>, <code>BlockingDeque</code>, <code>Semaphore</code>, <code>Lock</code>, <code>AtomicLong</code>, <code>CountDownLatch</code>, <code>Publish / Subscribe</code>, <code>Bloom filter</code>, <code>Remote service</code>, <code>Spring cache</code>, <code>Executor service</code>, <code>Live Object service</code>, <code>Scheduler service</code>) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p><a target="_blank" rel="noopener" href="https://redisson.org/">官网地址</a>：<a target="_blank" rel="noopener" href="https://redisson.org/">https://redisson.org/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">GitHub地址</a>：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p>
<p>看看Redisson能实现的功能：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566377069700.png" alt="1566377069700"> </p>
<h3 id="3-6-1-快速入门"><a href="#3-6-1-快速入门" class="headerlink" title="3.6.1.快速入门"></a>3.6.1.快速入门</h3><h4 id="1）依赖"><a href="#1）依赖" class="headerlink" title="1）依赖"></a>1）依赖</h4><p>使用起来非常方便，首先引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2）配置"><a href="#2）配置" class="headerlink" title="2）配置"></a>2）配置</h4><p>然后通过Java配置的方式，设置Redis的地址，构建RedissionClient客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置类</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setAddress(<span class="string">&quot;redis://192.168.206.99:6379&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3）常用API介绍："><a href="#3）常用API介绍：" class="headerlink" title="3）常用API介绍："></a>3）常用API介绍：</h4><p>RedissClient中定义了常见的锁：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556169332323.png" alt="1556169332323"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁对象，并制定锁的名称</span></span><br><span class="line">RLock lock = redissonClient.getLock(<span class="string">&quot;taskLock&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>获取锁对象后，可以通过<code>tryLock()</code>方法获取锁：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556169690541.png" alt="1556169690541"></p>
<p>有3个重载的方法，可以控制锁是否需要重试来获取：</p>
<ul>
<li>三个参数：获取锁，设置锁等待时间<code>waitTime</code>、释放时间<code>leaseTime</code>，时间单位<code>unit</code>。<ul>
<li>如果获取锁失败后，会在<code>waitTime  </code>减去获取锁用时的剩余时间段内继续尝试获取锁，如果依然获取失败，则认为获取锁失败；</li>
<li>获取锁后，如果超过<code>leaseTime</code>未释放，为避免死锁会自动释放。</li>
</ul>
</li>
<li>两个参数：获取锁，设置锁等待时间<code>time</code>、时间单位<code>unit</code>。释放时间<code>leaseTime</code>按照默认的30s</li>
<li>空参：获取锁，<code>waitTime</code>默认0s，即获取锁失败不重试，<code>leaseTime</code>默认30s</li>
</ul>
<p>任务执行完毕，使用<code>unlock()</code>方法释放锁：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1556170353278.png" alt="1556170353278"> </p>
<h4 id="4）完整案例"><a href="#4）完整案例" class="headerlink" title="4）完整案例"></a>4）完整案例</h4><p>使用Redission来代替我们之前自定义锁的测试案例：</p>
<p><img src="F:\java\01-重要部分：2021基础就业\06阶段：樂樂项目\分布式锁\笔记\assets\1566377926318.png" alt="1566377926318"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClearOrderTask2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/10 * * ? * *&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearOrderTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁对象</span></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试加锁</span></span><br><span class="line">        <span class="keyword">boolean</span> isLock = lock.tryLock();</span><br><span class="line">        <span class="comment">// 判断是否成功</span></span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，结束任务</span></span><br><span class="line">            log.error(<span class="string">&quot;获取锁失败，任务终止！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取锁成功，开始执行任务&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            clearOrder();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            log.warn(<span class="string">&quot;任务结束，释放锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearOrder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始清理未支付订单!&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        log.info(<span class="string">&quot;恢复数据库库存！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-2-Redisson实现细节"><a href="#3-6-2-Redisson实现细节" class="headerlink" title="3.6.2.Redisson实现细节"></a>3.6.2.Redisson实现细节</h3><p>首先看空参获取lock的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RedissonLock类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(tryLockAsync());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Boolean&gt; <span class="title">tryLockAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockAsync(Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Boolean&gt; <span class="title">tryLockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryAcquireOnceAsync(-<span class="number">1</span>, <span class="keyword">null</span>, threadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RFuture&lt;Boolean&gt; <span class="title">tryAcquireOnceAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁，返回RFuture(带结果的异步任务)</span></span><br><span class="line">    RFuture&lt;Boolean&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);</span><br><span class="line">    <span class="comment">// 如果成功</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">            <span class="comment">// 尝试自动续期（看门狗watch dog）</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的核心有两部分：</p>
<ul>
<li>一个是获取锁的方法：tryLockInnerAsync</li>
<li>一个是自动续期（看门狗）的方法：scheduleExpirationRenewal</li>
</ul>
<h4 id="1）获取锁"><a href="#1）获取锁" class="headerlink" title="1）获取锁"></a>1）获取锁</h4><p>首先看tryLockInnerAsync，这个方法是获取锁的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的核心就是这段Lua脚本，看看与我们写的是不是基本类似呢，区别是最后返回了这个key的剩余有效期。</p>
<h4 id="2）锁的自动续期"><a href="#2）锁的自动续期" class="headerlink" title="2）锁的自动续期"></a>2）锁的自动续期</h4><p>锁如果在执行任务时自动过期，就会引起各种问题， 因此我们需要在锁过期前自动申请续期，这个被称为watch dog，看门狗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建entry，记录线程id，因为需要知道对哪个线程的锁刷新</span></span><br><span class="line">    ExpirationEntry entry = <span class="keyword">new</span> ExpirationEntry();</span><br><span class="line">    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        <span class="comment">// 刷新过期时间</span></span><br><span class="line">        renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新时间的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置一个延迟刷新的任务，并且设置超时时间为总过期时间的1/3，例如总时间时30秒，则每隔10秒重试一次</span></span><br><span class="line">        Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">                <span class="keyword">if</span> (ent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Long threadId = ent.getFirstThreadId();</span><br><span class="line">                <span class="keyword">if</span> (threadId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 异步发送更新过期时间的请求</span></span><br><span class="line">                RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">                <span class="comment">// 更新成功后的任务</span></span><br><span class="line">                future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 再次调用自己</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刷新过期时间的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">renewExpirationAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">        Collections.&lt;Object&gt;singletonList(getName()), </span><br><span class="line">        internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3）带阻塞的获取锁"><a href="#3）带阻塞的获取锁" class="headerlink" title="3）带阻塞的获取锁"></a>3）带阻塞的获取锁</h4><p>阻塞获取锁，会在获取失败以后重试，不过会设置失败超时时间。</p>
<p><code>public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit)</code></p>
<ul>
<li>waitTime：获取锁重试的最大超时时间，默认为0</li>
<li>leaseTime：释放锁的最大时间，默认时30秒</li>
<li>unit：时间单位</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁的重试时长</span></span><br><span class="line">        <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">        <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 尝试获取锁，并获取有效时间</span></span><br><span class="line">        Long ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取锁成功，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算获取锁的耗时是否超过了最大重试时间</span></span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果超时则认为获取锁失败，不再重试，直接返回</span></span><br><span class="line">            acquireFailed(threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 虽然失败，但是没有超过最大等待时间，继续获取锁</span></span><br><span class="line">        current = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 订阅锁释放的消息</span></span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 此处会阻塞，等待消息。如果超时，则认为获取锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span><br><span class="line">                subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            acquireFailed(threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 如果获取到订阅消息，说明锁已经释放，可以重试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            time -= System.currentTimeMillis() - current;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                acquireFailed(threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="comment">// 循环重试获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">                ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    acquireFailed(threadId);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// waiting for message</span></span><br><span class="line">                currentTime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    acquireFailed(threadId);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unsubscribe(subscribeFuture, threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取锁失败，会通过Redis的pubsub功能订阅一个频道，如果释放锁会通知自己，然后再重试获取锁。</p>
<h4 id="4）释放锁"><a href="#4）释放锁" class="headerlink" title="4）释放锁"></a>4）释放锁</h4><p>释放锁代码基本一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RedisException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException) e.getCause();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面跟到unlockAsync方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;Void&gt;();</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line">	<span class="comment">// 回调</span></span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 出现异常的情况，取消自动续期任务</span></span><br><span class="line">            cancelExpirationRenewal(threadId);</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 说明锁是自动释放，已经不是自己的了</span></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            IllegalMonitorStateException cause = <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span></span><br><span class="line">                                                                                  + id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 取消自动续期任务</span></span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line">        result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后关键是释放锁的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span>+</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">                Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码基本一致，就是再最后释放成功后，通过<code>redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]);</code>发布了一条消息，通知锁已经释放，那些再等待的其它线程，就可以获取锁了。</p>
<h2 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7.总结"></a>3.7.总结</h2><p>总结来看，Redis实现分布式锁，具备下列优缺点：</p>
<ul>
<li>优点：实现简单，性能好，并发能力强，如果对并发能力有要求，推荐使用</li>
<li>缺点：可靠性有争议，极端情况会出现锁失效问题，如果对安全要求较高，不建议使用</li>
</ul>
<h1 id="4-zookeeper实现分布式锁"><a href="#4-zookeeper实现分布式锁" class="headerlink" title="4.zookeeper实现分布式锁"></a>4.zookeeper实现分布式锁</h1><p>Zookeeper是一种提供配置管理、分布式协同以及命名的中心化服务。</p>
<p>zk的模型是这样的：zk包含一系列的节点，叫做znode，就好像文件系统一样每个znode表示一个目录，然后znode有一些特性：</p>
<ul>
<li><p><strong>有序节点</strong>：假如当前有一个父节点为<code>/lock</code>，我们可以在这个父节点下面创建子节点；</p>
<p>zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号</p>
<p>也就是说，如果是第一个创建的子节点，那么生成的子节点为<code>/lock/node-0000000000</code>，下一个节点则为<code>/lock/node-0000000001</code>，依次类推。</p>
</li>
<li><p><strong>临时节点</strong>：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。</p>
</li>
<li><p><strong>事件监听</strong>：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：</p>
</li>
<li><ul>
<li>节点创建</li>
<li>节点删除</li>
<li>节点数据修改</li>
<li>子节点变更</li>
</ul>
</li>
</ul>
<p>基于以上的一些zk的特性，我们很容易得出使用zk实现分布式锁的落地方案：</p>
<ol>
<li><p>使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点，比如在/lock/目录下。</p>
</li>
<li><p>创建节点成功后，获取/lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点</p>
</li>
<li><p>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</p>
</li>
<li><p>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</p>
<p>比如当前线程获取到的节点序号为<code>/lock/003</code>,然后所有的节点列表为<code>[/lock/001,/lock/002,/lock/003]</code>,则对<code>/lock/002</code>这个节点添加一个事件监听器。</p>
</li>
</ol>
<p>如果锁释放了，会唤醒下一个序号的节点，然后重新执行第3步，判断是否自己的节点序号是最小。</p>
<p>比如<code>/lock/001</code>释放了，<code>/lock/002</code>监听到时间，此时节点集合为<code>[/lock/002,/lock/003]</code>,则<code>/lock/002</code>为最小序号节点，获取到锁。</p>
<p>Curator是一个zookeeper的开源客户端，也提供了分布式锁的实现。</p>
<p>来看看锁的一些特性Zookeeper是否满足：</p>
<ul>
<li><p>互斥：因为只有一个最小节点，满足互斥特性</p>
</li>
<li><p>锁释放：使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p>
</li>
<li><p>阻塞锁：使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p>
</li>
<li><p>可重入：使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p>
</li>
<li><p>高可用：使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p>
</li>
<li><p>高性能：Zookeeper集群是满足强一致性的，因此就会牺牲一定的性能，与Redis相比略显不足</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>优点：使用非常简单，不用操心释放问题、阻塞获取问题</li>
<li>缺点：性能比Redis稍差一些</li>
</ul>
<h1 id="5-基于数据库的实现"><a href="#5-基于数据库的实现" class="headerlink" title="5.基于数据库的实现"></a>5.基于数据库的实现</h1><p>准备一张表，记录锁相关信息:<code>tb_lock</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id	lockname</span><br><span class="line">1	createOrder</span><br><span class="line">2	evictOrder</span><br></pre></td></tr></table></figure>



<p>互斥：利用了数据库本身的排它锁来实现。</p>
<p>步骤：</p>
<ul>
<li>获取锁：select * from tb_lock where method_name = “evictOrder” for update</li>
<li>执行自己的业务 …</li>
<li>释放锁：commit 提交事务</li>
</ul>
<p>优点：</p>
<ul>
<li>实现简单</li>
<li>锁的自动释放</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖于数据库，性能是一个问题</li>
<li>单点故障问题</li>
<li>并发一般</li>
</ul>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><p>分布式锁释放方式多种多样，每种方式都有自己的优缺点，我们应该根据业务的具体需求，先择合适的实现。</p>
<p>Redis实现：实现比较简单，性能最高，但是可靠性难以维护</p>
<p>Zookeeper实现：实现最简单，可靠性最高，性能比redis略低</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">高明辉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">http://example.com/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Jason</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a></div><div class="post_share"><div class="social-share" data-image="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/17%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%B0%81%E9%9D%A2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="添加微信"/></a><div class="post-qr-code-desc">添加微信</div></li><li class="reward-item"><a href="/img/pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/pay.jpg" alt="付款码"/></a><div class="post-qr-code-desc">付款码</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"><img class="prev-cover" src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/18%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式日志服务、链路追踪</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img class="next-cover" src="/img/java/06%E9%98%B6%E6%AE%B5%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式事务</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.</span> <span class="toc-text">0.学习目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-SpringSchedule"><span class="toc-number">2.</span> <span class="toc-text">1.SpringSchedule</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6"><span class="toc-number">2.1.</span> <span class="toc-text">1.1.常见的定时任务框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.</span> <span class="toc-text">1.2.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.3.</span> <span class="toc-text">1.3.快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.3.1.创建项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.3.2.开启定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.3.3.定义任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">1.3.4.启动测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">1.4.配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.4.1.任务线程池大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%AE%9A%E6%97%B6%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">1.4.2.定时策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-cron%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.4.3.</span> <span class="toc-text">1.4.3.cron表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">2.认识分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.</span> <span class="toc-text">2.1.业务场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.2.</span> <span class="toc-text">2.2.为什么需要分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1.线程锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2.分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">3.Redis实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%89%88%E6%9C%AC1-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">3.1.版本1-基本实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%89%88%E6%9C%AC2-%E4%BA%92%E6%96%A5%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">3.2.版本2-互斥性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1.问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2.解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.2.3.代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%89%88%E6%9C%AC3-%E9%87%8D%E5%85%A5%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">3.3.版本3-重入性（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.4.1.重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.4.2.流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Lua%E8%84%9A%E6%9C%AC"><span class="toc-number">4.4.</span> <span class="toc-text">3.4.Lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Redis%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8CLua%E8%84%9A%E6%9C%AC"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.4.1.Redis中如何执行Lua脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-Lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.4.2.Lua脚本的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E7%BC%96%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84Lua%E8%84%9A%E6%9C%AC"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.4.3.编写分布式锁的Lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%99%AE%E9%80%9A%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">1）普通互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9A"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">2）可重入锁：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8Lua"><span class="toc-number">4.5.</span> <span class="toc-text">3.5.Redis客户端调用Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E9%94%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.1.</span> <span class="toc-text">3.5.1.锁接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">4.5.2.</span> <span class="toc-text">3.5.2.实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E8%8E%B7%E5%8F%96%E9%94%81%E7%9A%84%E5%B7%A5%E5%8E%82"><span class="toc-number">4.5.3.</span> <span class="toc-text">3.5.3.获取锁的工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E6%B5%8B%E8%AF%95"><span class="toc-number">4.5.4.</span> <span class="toc-text">3.5.4.测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Redisson"><span class="toc-number">4.6.</span> <span class="toc-text">3.6.Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">4.6.1.</span> <span class="toc-text">3.6.1.快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%BE%9D%E8%B5%96"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">1）依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%85%8D%E7%BD%AE"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">2）配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%B8%B8%E7%94%A8API%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">3）常用API介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%AE%8C%E6%95%B4%E6%A1%88%E4%BE%8B"><span class="toc-number">4.6.1.4.</span> <span class="toc-text">4）完整案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-Redisson%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">4.6.2.</span> <span class="toc-text">3.6.2.Redisson实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">1）获取锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%94%81%E7%9A%84%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">2）锁的自动续期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%B8%A6%E9%98%BB%E5%A1%9E%E7%9A%84%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">3）带阻塞的获取锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">4.6.2.4.</span> <span class="toc-text">4）释放锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E6%80%BB%E7%BB%93"><span class="toc-number">4.7.</span> <span class="toc-text">3.7.总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">4.zookeeper实现分布式锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">5.基于数据库的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">6.总结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 高明辉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Aaee0Vekhg5KbLhMOJQrEU6A-gzGzoHsz',
      appKey: 'mmLHPEEtqvOSJhsqWra8Sq6K',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script type="text/javascript" src="/js/fairyDustCursor.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>